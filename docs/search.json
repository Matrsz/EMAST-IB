[
  {
    "objectID": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "href": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "title": "",
    "section": "",
    "text": "\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\]\nReemplazando 2 en 1:\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\]\nDespejando:\n\\[\n(Js^2  + C_d s + C_p) \\Theta(s) = C_p \\Theta_{ref}(s)\n\\]\nDe esta forma se verifica la función de transferencia\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{C_p}{Js^2  + C_d s + C_p}\n\\]\no bien,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\]\nPara relacionar esto con la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\)\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\]\nSe obtiene diréctamente\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}\n\\]\nAdemás,\n\\[\n\\frac{C_d}{J} = 2\\xi \\sqrt{\\frac{C_p}{J}} \\implies \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}\\]\nEn particular, con los valores dados en la tabla\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\)\n\\[\nC_p = \\omega_n^2J = 10 \\text{ kg m²/s²}\n\\]\n\\[\nC_d = 2\\xi\\omega_n J = 140 \\text{ kg m²/s}\n\\]\n\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J\n\nVamos con el grande…\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{LP1}(s)) + N_{LP2}(s)\\right)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{LP1}(s))\n\\]\nReemplazando:\n\\[\nJs^2\\Theta(s)-N_{LP1}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(s \\Theta(s) + N_{LP2}(s)\\right)\n\\]\nAgrupando a un lado:\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{LP3}(s) - C_dN_{LP2}(s) + N_{LP1}(s)\n\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\Theta(s) = \\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{LP3}(s) + \\frac{- C_d}{Js^2+C_d s + C_p}N_{LP2}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{LP1}(s)\n\\]\n\nimport scipy.signal as signal\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nH_1 = signal.TransferFunction([1], [J, C_d, C_p])\nH_2 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_3 = signal.TransferFunction([-C_p], [J, C_d, C_p])\n\nt_s = 1e-2\n\nN = 100000\n\ntheta_ref = np.random.normal(0, 1, N)\nt = np.linspace(0, N*t_s, N)\n\nT, theta1, _ = signal.lsim(H_1, theta_ref, t)\nT, theta2, _ = signal.lsim(H_2, theta_ref, t)\nT, theta3, _ = signal.lsim(H_3, theta_ref, t)\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, theta1)\nax[1].plot(T, theta2)\nax[2].plot(T, theta3)\n\n\n\n\n\n\n\n\n\nT, h1 = signal.impulse(H_1)\nT, h2 = signal.impulse(H_2)\nT, h3 = signal.impulse(H_3)\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, h1)\nax[1].plot(T, h2)\nax[2].plot(T, h3)\n\n\n\n\n\n\n\n\n\nf = np.fft.fftshift(np.fft.fftfreq(N, t_s))\npsd_N = np.array([1/t_s for x in f])\n\ndef H_1fun(f):\n    w = 2*np.pi*f\n    return 1/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_2fun(f):\n    w = 2*np.pi*f\n    return -C_d/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_3fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_1 = np.array([np.abs(H_1fun(fi))**2 for fi in f])*psd_N\nS_2 = np.array([np.abs(H_2fun(fi))**2 for fi in f])*psd_N\nS_3 = np.array([np.abs(H_3fun(fi))**2 for fi in f])*psd_N\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(f, S_1)\nax[1].plot(f, S_2)\nax[2].plot(f, S_3)\nfor i in [0,1,2]:\n    ax[i].set_xlim((-1,1))"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html",
    "href": "TP1_Propagación_Ruido_LTI.html",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "href": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "href": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Consideración de fuentes de ruido",
    "text": "Consideración de fuentes de ruido\nAl considerar las fuentes de ruido que alejan al comportamiento del sistema representado en la Figura 2 de su comportamiento ideal,\n\nWNTN2: Ruido de torque\nWNRS5: Ruido de velocidad\nWNPS8: Ruido de posición\n\nse obtiene el diagrama en bloques representado en la Figura 3.\n\n\n\n\n\n\nFigura 3: Diagrama de bloques del sistema considerando fuentes de ruido.\n\n\n\nLos ruidos se representan como ruido coloreado con frecuencia de corte \\(\\omega_C\\), y se expresan de la siguiente forma\n\\[\nN(s) = \\frac{\\omega_{c}}{s+\\omega_{c}}W(s)\n\\]\nEn donde \\(W(s)\\) es ruido blanco gausiano.\nIncorporando estos términos de ruido, la Ecuación 1 se convierte en la Ecuación 7,\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{P}(s)) + N_{V}(s)\\right)\n\\tag{7}\\]\nY la Ecuación 2 se convierte en la Ecuación 8,\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{P}(s))\n\\tag{8}\\]\nReemplazando la Ecuación 8 en la Ecuación 7 se obtiene\n\\[\nJs^2\\Theta(s)-N_{P}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(s \\Theta(s) + N_{V}(s)\\right)\n\\tag{9}\\]\nExpresando \\(\\Theta(s)\\) en función de los demás términos se obtiene\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{T}(s) - C_dN_{V}(s) + N_{P}(s)\n\\tag{10}\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\begin{aligned}\n\\Theta(s) = &\\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{11}\\]\nLa Ecuación 10 describe las contribuciones de la referencia a la posición angular, así como de los tres términos de ruido. Además, al cumplirse \\(\\dot{\\Theta}(s)=s\\Theta(s)\\), se obtiene la ecuación de la velocidad angular en función de sus contribuciones.\n\\[\n\\begin{aligned}\n\\dot{\\Theta}(s) = &\\frac{C_p s}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p s}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d s}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{s}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{12}\\]\nAplicando el principio de superposición, la Ecuación 11 y Ecuación 12 se pueden expresar de la siguiente forma\n\\[\n\\begin{aligned}\n\\Theta(s) = &H_{0}(s) \\Theta_{ref}(s) + H_{T0}(s)N_{T}(s) + H_{V0}(s)N_{V}(s) + H_{P0}(s)N_{P}(s)\\\\[1em]\n\\dot{\\Theta}(s) = &H_{1}(s) \\Theta_{ref}(s) + H_{T1}(s)N_{T}(s) + H_{V1}(s)N_{V}(s) + H_{P1}(s)N_{P}(s)\n\\end{aligned}\n\\tag{13}\\]\n\nEn donde las transferencias del ruido son \\[\n\\begin{matrix}\nH_{T0}(s) = \\dfrac{- C_p}{Js^2+C_d s + C_p}&\nH_{T1}(s) = \\dfrac{- C_p s}{Js^2+C_d s + C_p}\\\\\nH_{V0}(s) = \\dfrac{- C_d}{Js^2+C_d s + C_p}&\nH_{V1}(s) = \\dfrac{- C_d s}{Js^2+C_d s + C_p}\\\\\nH_{P0}(s) = \\dfrac{1}{Js^2+C_d s + C_p}&\nH_{P1}(s) = \\dfrac{s}{Js^2+C_d s + C_p}\\\\\n\\end{matrix}\n\\tag{14}\\]\n\n\nCódigo\nimport scipy.signal as signal\n\nH_t0 = signal.TransferFunction([-C_p], [J, C_d, C_p])\nH_v0 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_p0 = signal.TransferFunction([1], [J, C_d, C_p])\nH_t1 = signal.TransferFunction([-C_p, 0], [J, C_d, C_p])\nH_v1 = signal.TransferFunction([-C_d, 0], [J, C_d, C_p])\nH_p1 = signal.TransferFunction([1, 0], [J, C_d, C_p])\n\n\n\nRespuesta al Impulso\nSe procede a analizar las respuestas al impulso del sistema, dadas por\n\\[\nh_i(t) = \\mathcal{L}^{-1}\\left\\{H_i(s)\\right\\}\n\\]\nEstas se pueden calcular analíticamente, o bien utilizando scipy.signal.impulse. Los resultados se presentan en la Figura 4 y la Figura 5.\n\n\nCódigo\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_theme()\n\nT, h_t0 = signal.impulse(H_t0)\nT, h_v0 = signal.impulse(H_v0)\nT, h_p0 = signal.impulse(H_p0)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t0)\nax[1].plot(T, h_v0)\nax[2].plot(T, h_p0)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\theta$')\nax[0].set_ylabel(r'$h_{T0}$')\nax[1].set_ylabel(r'$h_{V0}$')\nax[2].set_ylabel(r'$h_{P0}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 4: Respuestas al impulso de las fuentes de ruido sobre la posición angular.\n\n\n\n\n\n\n\nCódigo\nT, h_t1 = signal.impulse(H_t1)\nT, h_v1 = signal.impulse(H_v1)\nT, h_p1 = signal.impulse(H_p1)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t1)\nax[1].plot(T, h_v1)\nax[2].plot(T, h_p1)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\dot\\theta$')\nax[0].set_ylabel(r'$h_{V1}$')\nax[1].set_ylabel(r'$h_{V1}$')\nax[2].set_ylabel(r'$h_{V1}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 5: Respuestas al impulso de las fuentes de ruido sobre la velocidad angular.\n\n\n\n\n\nLos resultados presentados en las figuras indican un estado transitorio de aproximadamente \\(50\\) s, lo cual da una noción de la escala temporal del sistema. Este resultado motiva la elección de un tiempo de muestreo de \\(T_s = 10\\) ms para realizar una simulación digital del sistema."
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "href": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Análisis de la respuesta del sistema ante ruido blanco",
    "text": "Análisis de la respuesta del sistema ante ruido blanco\nA partir de los gráficos de las respuestas al impulso presentados en la Figura 4 y Figura 5, así como las expresiones de las transferencias presentadas en la Ecuación 13, se determina que la respuesta del sistema ante las fuentes de ruido solo varía por un factor multiplicativo. Por este motivo se procede únicamente a analizar la respuesta al ruido de torque, sabiendo que el comportamiento ante el ruido de posición y el ruido de velocidad será similar.\n\nSimulación temporal\nPara simular la respuesta del sistema ante ruido blanco, se define una señal de entrada \\(n_T[t]\\) de \\(N\\) muestras independientes idénticamente distribuidas, definida por\n\\[\n  \\mathbf{n_T} \\sim \\mathcal{N}(\\mathbf 0_N, \\sigma^2 I_N)\n\\]\nA partir de esta señal se simulan las salidas, \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\), utilizando scipy.signal.lsim.\n\n\nCódigo\nimport numpy as np\n\nt_s = 1e-2\nvar_n = 100\nN = 400000\nt = np.linspace(0, N*t_s, N)\n\nn_t = np.random.normal(0, np.sqrt(var_n), N)\n\nT, pos, _ = signal.lsim(H_t0, n_t, t)\nT, vel, _ = signal.lsim(H_t1, n_t, t)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nfig.suptitle('Respuestas del sistema ante una entrada de ruido blanco', fontsize=16)\nax[0].plot(T, n_t)\nax[1].plot(T, pos)\nax[2].plot(T, vel)\nax[0].set_ylabel(r'$n_T$')\nax[1].set_ylabel(r'$\\theta$')\nax[2].set_ylabel(r'$\\dot\\theta$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(0,800)\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 6: Respuestas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nSe calcula el valor cuadrático medio empírico de las señales con la fórumla\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\frac{1}{N}\\sum_{t=0}^{N-1}x^2[t]\n\\]\nLos resultados para la realización vista en la Figura 6 se presentan a continuación\n\n\nCódigo\ndef round_sig_figs(value, sig_figs):\n    if value == 0:\n        return 0\n    else:\n        return round(value, sig_figs - int(np.floor(np.log10(abs(value)))) - 1)\n\nmsv_ruido = np.mean([n**2 for n in n_t])\nmsv_pos = np.mean([n**2 for n in pos])\nmsv_vel = np.mean([n**2 for n in vel])\n\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     99.9\nValor cuadrático medio de la posición angular:   0.0417\nValor cuadrático medio de la velocidad angular:  0.000401\n\n\n\n\nAnálisis en el dominio de la frecuencia\nSe procede a calcular la distribución espectral de potencia de \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\) ante la entrada \\(n_T[t]\\), a partir de la expresión teórica\n\\[\n\\begin{aligned}\nS_\\theta(f) &= \\left| H_{T0}(j2\\pi f) \\right|^2 S_{N_T}(f)\\\\\nS_{\\dot\\theta}(f) &= \\left| H_{T1}(j2\\pi f) \\right|^2 S_{N_T}(f)\n\\end{aligned}\n\\]\nEn donde \\(S_{n_T}\\) es la distribución espectral de potencia de ruido blanco con varianza \\(\\sigma^2\\) muestreado a una frecuencia \\(f_s = 1/T_S\\)\n\\[\n  S_{N_T}(f) = \\frac{\\sigma^2}{f_S} \\Pi\\left(\\frac{f}{f_S}\\right)\n\\]\n\n\nCódigo\nf = np.fft.fftfreq(N, t_s)\npsd_N = np.array([var_n*t_s for x in f])\n\ndef H_T0fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_T1fun(f):\n    w = 2*np.pi*f\n    return -C_p*(1j*w)/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_0 = np.array([np.abs(H_T0fun(fi))**2 for fi in f])*psd_N\nS_1 = np.array([np.abs(H_T1fun(fi))**2 for fi in f])*psd_N\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].loglog(f[0:N//2], psd_N[0:N//2])\nax[1].loglog(f[0:N//2], S_0[0:N//2])\nax[2].loglog(f[0:N//2], S_1[0:N//2])\nfig.suptitle('Distribución Espectral de Potencia')\nax[0].set_ylabel(r'$S_{N_T}$')\nax[1].set_ylabel(r'$S_{\\Theta}$')\nax[2].set_ylabel(r'$S_{\\dot\\Theta}$')\nax[2].set_xlabel(r'$f$ [Hz]')\nfor i in [0,1,2]:\n    ax[i].grid(True)\n\n\n\n\n\n\n\n\nFigura 7: Distribución espectral de potencia de las salidas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nLa Figura 7 indica que \\(H_{T0}\\) actúa como un filtro pasa bajo, mientras que \\(H_{T1}\\) actúa como un filtro pasa banda. Esto es consistente con un análisis cualitativo de las formas de onda presentadas en la Figura 6, así como de las tranferencias presentadas en la Ecuación 13.\nFinalmente, se calcula el valor cuadrático medio teórico de las señales, dado por\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\int_{-\\infty}^{\\infty} S_X(f) df\n\\]\nLos resultados utilizando integración numérica se presentan a continuación.\n\n\nCódigo\nf = np.fft.fftshift(f)\nS_0 = np.fft.fftshift(S_0)\nS_1 = np.fft.fftshift(S_1)\n\nmsv_ruido = np.trapezoid(psd_N, f)\nmsv_pos = np.trapezoid(S_0, f)\nmsv_vel = np.trapezoid(S_1, f)\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     100.0\nValor cuadrático medio de la posición angular:   0.0357\nValor cuadrático medio de la velocidad angular:  0.000357"
  },
  {
    "objectID": "kalman2.html",
    "href": "kalman2.html",
    "title": "",
    "section": "",
    "text": "using LinearAlgebra\nusing Distributions\nusing Plots\nusing ColorSchemes\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\n\nprintln(Q)\nprintln(R)\n\n[6.4000000000000006e-6 0.0 0.0; 0.0 6.4000000000000006e-6 0.0; 0.0 0.0 2.7415567780803773e-6]\n[6.25 0.0 0.0; 0.0 6.25 0.0; 0.0 0.0 1.5551418366801118e-7]\n\n\n\ndiagm([10,10,10])\n\n3×3 Matrix{Int64}:\n 10   0   0\n  0  10   0\n  0   0  10\n\n\n\n# Generadores de datos \n\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\n## Matrices filtro Kalman\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\n3×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  1\n\n\n\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\nfunction kalman_initialize(t, tasa_GPS, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N÷tasa_GPS)\n    return x, P, K\nend\n\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, tasa_GPS, z)\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est)\n            K[:,:,k÷tasa_GPS] = K_k\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P\nend\n\nkalman (generic function with 1 method)\n\n\n\nT = 500\nt = 0:0.1:T\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\nu = u_true + u_noise\nz = z_true + z_noise\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.22380275271364 … -0.17930100163669135 -0.1795083568166394; 0.0 -0.0003103366528196452 … -0.0018967979237825012 -0.002250305675178356; … ; 0.0 -0.00041613986353679247 … -0.0077613489996968725 -0.007801436660320887; -0.0002794640187689196 -0.00030817631756576455 … 2.2592111624671762e-5 -2.8431199440788638e-5], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.013290796118887e-28 0.0; 0.6250000032 6.250000064 … 2.4943584589793974e-28 0.0; … ; -7.088765594317273e-31 -4.395064373185345e-28 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … 7.38064560983693e-29 0.0; 1.2500000128000002 6.250000128 … 9.772577152374617e-28 0.0; … ; -6.938253732913538e-29 9.258807670461116e-28 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … 3.8033289446895193e-25 0.0; 0.002020370544845382 5.0854141278523966e-5 … -1.920307048984724e-26 0.0; … ; -3.9438733496621813e-26 2.854035111629257e-26 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … 3.6088972364073983e-25 0.0; 0.001974861075922868 5.027814120589553e-5 … -1.788868929978571e-26 0.0; … ; -3.379204849591105e-26 2.942533968508753e-26 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … 3.5909621971294503e-25 0.0; 0.001979892090043457 5.034214120589553e-5 … -1.78501228015534e-26 0.0; … ; -3.0856407044011273e-26 2.9440959920039314e-26 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t (generic function with 1 method)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\nfunction estimation_error(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\nfunction plot_error(t, x, z_true, P)\n    p1 = plot(t, varianza_estimador(P))\n    p2 = plot(t, estimation_error(x, z_true))\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction mru_IMU()\n    return [0,0,0]\nend\nfunction mru_GPS(v, t, θ)\n    return [v*t*cos(θ),v*t*sin(θ),θ]\nend\n\nmru_GPS (generic function with 1 method)\n\n\n\nt_gps = t[1:10:end]\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([mru_GPS(100/T, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.2237834951726105 … 70.58344470989839 70.59774251957364; 0.0 7.481416776940403e-5 … 0.143088907488292 0.14286728601674714; … ; 0.0 -0.0005136964710884169 … 0.13551697562445592 0.13523866163957277; 0.7851186993786794 0.7850899870798825 … 0.785420755509073 0.7853697321980075], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.1092301608009414e-25 0.0; 0.6250000032 6.250000064 … 3.9049200030955144e-25 0.0; … ; 1.9507123971656156e-25 1.1683928264965458e-24 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … -3.719139900271429e-26 0.0; 1.2500000128000002 6.250000128 … 8.275884030191062e-25 0.0; … ; 8.750696298758388e-26 4.391923111483954e-25 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … -1.8807255502262903e-21 0.0; 0.002020370544845382 5.0854141278523966e-5 … -6.360334456139304e-23 0.0; … ; 1.675403548287672e-21 2.937425523829086e-23 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … -1.8180632741629165e-21 0.0; 0.001974861075922868 5.027814120589553e-5 … -6.027221892540865e-23 0.0; … ; 1.61435427376303e-21 3.103030558032755e-23 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … -1.824114592005475e-21 0.0; 0.001979892090043457 5.034214120589553e-5 … -6.010226026335021e-23 0.0; … ; 1.6173663075581039e-21 3.152330368175671e-23 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\n3×5001 Matrix{Float64}:\n 18.7762    19.9011   24.5303    22.248    …  19.5701   19.6944   20.2105\n  0.739645  -3.65581  -0.937314   2.46585      2.6014   -3.40718  -2.94765\n  1.57052    1.57188   1.57352    1.57431      7.85118   7.85282   7.85396\n\n\n\nx, P = kalman(t, 10, u, z)\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)"
  },
  {
    "objectID": "kalman.html",
    "href": "kalman.html",
    "title": "",
    "section": "",
    "text": "using LinearAlgebra\nusing Distributions\nusing Plots\nusing ColorSchemes\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\n\nprintln(Q)\nprintln(R)\n\n[6.4000000000000006e-6 0.0 0.0; 0.0 6.4000000000000006e-6 0.0; 0.0 0.0 2.7415567780803773e-6]\n[6.25 0.0 0.0; 0.0 6.25 0.0; 0.0 0.0 1.5551418366801118e-7]\n\n\n\n# Generadores de datos \n\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\n## Matrices filtro Kalman\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\n3×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  1\n\n\n\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    K = P_est*H'*inv(H*P_est*H'+R)\n    return x_est, P_est, K\nend\n\nfunction kalman_correct(x_prior, z, P_prior, K)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est\nend\n\nfunction kalman_initialize(t, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N)\n    return x, P, K\nend\n\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, z)\n    for k in 2:length(t)\n        x_est, P_est, K_k = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est = kalman_correct(x_est, z[:,k], P_est, K_k)\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n        K[:,:,k] = K_k\n    end\n    return x, P, K\nend\n\nkalman (generic function with 1 method)\n\n\n\nT = 500\nt = 0:0.1:T\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\nu = u_true + u_noise\nz = z_true + z_noise\nx, P, K = kalman(t, 10, u, z)\n\n([-3.437172170088852 -3.437170067606941 … -0.05514864048733337 -0.0549463982529141; 0.0 4.2049638219432486e-5 … 0.002251057155687055 0.0017937875326982514; … ; 0.0 0.0002790696015042668 … 0.008183487598527939 0.007421000771058218; -0.0004533360878956477 -0.0007231607468178242 … -0.0005320521099213215 -0.0005290357290462975], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 3.0132212732029537e-29 0.0; 0.6250000032 6.250000064 … 6.026445866657267e-28 0.0; … ; 2.566549783865771e-29 -5.9232401974700555e-28 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … -2.7410752269784475e-28 0.0; 1.2500000128000002 6.250000128 … -5.071850471591023e-27 0.0; … ; 8.923795762240636e-29 2.9051123060548158e-27 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … -1.740930778211156e-24 0.0; 0.002020370544845382 5.0854141278523966e-5 … -3.467292129763258e-26 0.0; … ; 4.822885123211525e-25 -2.3141436261075262e-26 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … -1.6769280836617653e-24 0.0; 0.001974861075922868 5.027814120589553e-5 … -3.9267951682414015e-26 0.0; … ; 4.543353553543053e-25 -2.5461211538868014e-26 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … -1.680998494744691e-24 0.0; 0.001979892090043457 5.034214120589553e-5 … -4.246338758581635e-26 0.0; … ; 4.518889006387876e-25 -2.7251873943435294e-26 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.5024875621953911 -2.4118042868039214e-31 0.0; 0.04975124403518725 1.5815118399709317e-30 0.0; … ; 2.0622839300917425e-30 0.04975124403518725 0.0; 0.0 0.0 0.9999999752491497;;; 0.5098039216301423 4.139587111507692e-31 0.0; 0.09803921667789314 2.1707502396533502e-29 0.0; … ; 7.031738238087003e-30 0.09803921667789314 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.024919500025468617 -1.1889583301111918e-23 0.0; 0.0003152038273602642 -2.6805599923539317e-25 0.0; … ; 7.316017240240293e-26 0.0003152038273602642 0.0; 0.0 0.0 0.6968640780830011;;; 0.024981043348223344 -1.1941122658176598e-23 0.0; 0.00031597777214765885 -2.6850565982841924e-25 0.0; … ; 7.269365685668885e-26 0.00031597777214765885 0.0; 0.0 0.0 0.7122418117142865;;; 0.024432425896073577 -1.141589957540396e-23 0.0; 0.00030904296372339973 -2.5893588148996656e-25 0.0; … ; 6.858441989603416e-26 0.00030904296372339973 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\nprintln(length(t))\n\n5001\n\n\n\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t (generic function with 1 method)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\nfunction estimation_error(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\nfunction kalman_gain(K)\n    return [norm(K[:,:,i]) for i in 1:size(K,3)]\nend\n\nfunction plot_error(t, x, z_true, P)\n    v = varianza_estimador(P)\n    e = estimation_error(x, z_true)\n    p1 = plot(t, v, ylim=[0, maximum(v)*1.1], ylabel=\"tr[P]\")\n    p2 = plot(t, e, ylim=[0, maximum(e)*1.1], ylabel=\"Error cuadrático\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction plot_gain(t, P, K)\n    v = varianza_estimador(P)\n    k = kalman_gain(K)\n    p1 = plot(t, v, ylim=[0, maximum(v)*1.1], ylabel=\"tr[P]\")\n    p2 = plot(t, k, ylim=[0, maximum(k)*1.1], ylabel=\"norm[K]\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_gain (generic function with 1 method)\n\n\n\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction mru_IMU()\n    return [0,0,0]\nend\nfunction mru_GPS(v, t, θ)\n    return [v*t*cos(θ),v*t*sin(θ),θ]\nend\n\nmru_GPS (generic function with 1 method)\n\n\n\nt_gps = t[1:10:end]\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([mru_GPS(100/T, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n([-3.437172170088852 -3.4371805500100177 … 70.42753125927538 70.44163038344469; 0.0 -0.00016759842331529284 … 0.14088333111565546 0.1410991522706787; … ; 0.0 0.00022706559197809633 … 0.15198424448381923 0.15112174642630397; 0.7849448273095526 0.7846750026506304 … 0.784866111287527 0.7848691276684021], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.179808407269431e-25 0.0; 0.6250000032 6.250000064 … -2.885189585345663e-24 0.0; … ; 1.7781507665368613e-25 -2.442855625326188e-24 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … 1.3837028614823992e-25 0.0; 1.2500000128000002 6.250000128 … -4.978827631758677e-24 0.0; … ; 1.3698520518111092e-25 -4.288706713749247e-24 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … 9.014604622213589e-22 0.0; 0.002020370544845382 5.0854141278523966e-5 … 1.3075201124897577e-23 0.0; … ; -1.8872805479580838e-21 -4.858942682068063e-23 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … 8.598741490615176e-22 0.0; 0.001974861075922868 5.027814120589553e-5 … 1.0350427272669325e-23 0.0; … ; -1.8237033848783837e-21 -4.8219180871328724e-23 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … 8.609067123136971e-22 0.0; 0.001979892090043457 5.034214120589553e-5 … 1.1783009628642441e-23 0.0; … ; -1.8287462434380612e-21 -4.7925207499964306e-23 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.5024875621953911 -2.3616826091578174e-28 0.0; 0.04975124403518725 -1.9645349885825827e-26 0.0; … ; 1.4162603667374015e-26 0.04975124403518725 0.0; 0.0 0.0 0.9999999752491497;;; 0.5098039216301423 -1.7963477933880412e-27 0.0; 0.09803921667789314 -6.44043584130298e-26 0.0; … ; 1.1013745726617063e-26 0.09803921667789314 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.024919500025468617 9.968885497737289e-21 0.0; 0.0003152038273602642 1.377239997378521e-22 0.0; … ; -2.9110783241439195e-22 0.0003152038273602642 0.0; 0.0 0.0 0.6968640780830011;;; 0.024981043348223344 9.995098989025721e-21 0.0; 0.00031597777214765885 1.3787573405698012e-22 0.0; … ; -2.9179254158054134e-22 0.00031597777214765885 0.0; 0.0 0.0 0.7122418117142865;;; 0.024432425896073577 9.538887700215152e-21 0.0; 0.00030904296372339973 1.316719896096268e-22 0.0; … ; -2.823081096071746e-22 0.00030904296372339973 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nk1 = 4000\nk2 = 4200\nplot_error(t[k1:k2], x[:,k1:k2], z_true[:,k1:k2], P[:,:,k1:k2])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\n3×5001 Matrix{Float64}:\n 16.5628    19.5023   23.6845    19.03     …  22.6308    22.6504   22.8569\n -0.268929   1.18634   0.423407  -3.41143     -0.592076   2.48937   3.36965\n  1.57034    1.57214   1.57367    1.57401      7.8517     7.85236   7.85422\n\n\n\nx, P, K = kalman(t, 10, u, z)\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nk1 = 4000\nk2 = 4200\nplot_error(t[k1:k2], x[:,k1:k2], z_true[:,k1:k2], P[:,:,k1:k2])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction kalman_correct(x_prior, z, P_prior, K, GPS=true, mag=true)\n    if GPS && mag\n      H2 = H\n      z2 = z\n      R2 = R\n    elseif mag\n      H2 = H[3,:]'\n      z2 = z[3]\n      R2 = R[3,3]\n    else\n      H2 = H[1:2, :]\n      z2 = z[1:2]\n      R2 = R[1:2,1:2]\n    end  \n    K = P_prior*H2'*inv(H2*P_prior*H2'+R2)\n    x_est = x_prior + K*(z2-H2*x_prior)\n    P_est = (I-K*H2)*P_prior\n    return x_est, P_est, K\n  end\n  \n  function kalman(t, tasa_GPS, u, z, Q, R, gps, mag)\n      x, P, K = kalman_initialize(t, z, R)\n      K = zeros(size(t))\n      for k in 2:length(t)\n          x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1], Q)\n          if k%tasa_GPS == 0\n              x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est, R, gps[k], mag[k])\n            K[k] = norm(K_k)\n          end\n          x[:,k] = x_est\n          P[:,:,k] = P_est\n      end\n      return x, P, K\n  end\n  \n  function kalman_predict(x, u, P, Q)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n  function kalman_initialize(t, z, R)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([R[1,1]^2,(R[1,1]*fs2)^2,R[2,2]^2,(R[2,2]*fs2)^2,2pi])\n    K = zeros(5, 3, N)\n    return x, P, K\nend\n\nkalman_initialize (generic function with 2 methods)\n\n\n\ngps_sig = ones(size(t)) .|&gt; Bool\nmag_sig = ones(size(t)) .|&gt; Bool\ngps_sig[3001:4000] = zeros(1000) .|&gt; Bool\n\n1000-element BitVector:\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n ⋮\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\nQ = [(err_IMU_x)^2 0 0; 0 (err_IMU_x)^2 0; 0 0 (err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, gps_sig, mag_sig)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, mag_sig, gps_sig)\n\n([19.34614215897161 19.346119851348885 … 19.99328045085733 19.993871292556964; 0.0 -0.0004461524544820676 … 0.005978293900963865 0.005838540091720454; … ; 0.0 -0.00014165431251806913 … 0.2623050866881833 0.2630617446368394; 1.570283476723263 1.571456629111551 … 7.852661931752863 7.853835199901739], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.45312500016 3.9062500032 … 2.929752672094091e-28 0.0; 3.9062500032 39.062500064 … -4.0921018160818156e-27 0.0; … ; 2.9274784435890066e-28 5.563218947493499e-27 … 39.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 40.6250000016 7.8125000128 … -7.012963836232524e-29 0.0; 7.8125000128 39.062500127999996 … -5.711112357581009e-27 0.0; … ; 9.346958772904156e-28 8.172271131782737e-27 … 39.062500127999996 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972723750735476 0.00202037050907998 … -3.244480209526759e-22 0.0; 0.0020203705090799796 5.085414131495572e-5 … -5.8511729223730434e-24 0.0; … ; 6.533371018053186e-23 -9.811273445853477e-24 … 5.085414131495572e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315593807332 0.0019748610285924453 … -3.119055550214522e-22 0.0; 0.001974861028592445 5.027814126896574e-5 … -5.631146418548519e-24 0.0; … ; 5.628713182804075e-23 -9.866658372086775e-24 … 5.027814126896574e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.1565270345278644 0.0019798920427193415 … -3.1246847571185604e-22 0.0; 0.001979892042719341 5.034214126896574e-5 … -5.629450374144675e-24 0.0; … ; 5.530078889528889e-23 -9.870495500822092e-24 … 5.034214126896574e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.7623134290242808  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7131175945847074, 0.0])\n\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5001-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html",
    "href": "TP2_Filtro_Kalman.html",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\).\n\n\n\nCódigo\nusing LinearAlgebra\nusing Distributions\nusing Plots\nusing PlotThemes\n\ntheme(:wong2)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "href": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\).\n\n\n\nCódigo\nusing LinearAlgebra\nusing Distributions\nusing Plots\nusing PlotThemes\n\ntheme(:wong2)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "href": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "title": "TP2 - Filtros de Kalman",
    "section": "Error de los instrumentos",
    "text": "Error de los instrumentos\nPara cada dimensión de medición se considera su correspondiente error. Se hace a partir de los datos en la hoja de datos.\n\n\n\n\n\n\n\n\nParámetro\nSímbolo\nValor\n\n\n\n\nFrecuencia de muestreo IMU\n\\(f_s\\)\n\\(10 \\, \\mathrm{Hz}\\)\n\n\nFrecuencia de muestreo GPS\n\\(f_s'\\)\n\\(1 \\, \\mathrm{Hz}\\)\n\n\nPSD ruido acelerómetro\n\\(S_{acc}\\)\n\\(80\\, \\mathrm{\\mu g}/\\sqrt{\\mathrm{Hz}}\\)\n\n\nPSD ruido giróscopo\n\\(S_{gir}\\)\n\\(0.03\\, ^\\circ/s/\\sqrt{\\mathrm{Hz}}\\)\n\n\nPSD ruido giróscopo\n\\(S_{gir}\\)\n\\(100\\, \\mathrm{\\mu Gauss}/\\sqrt{\\mathrm{Hz}}\\)\n\n\nError absoluto del GPS\n\\(\\sigma_{GPS}\\)\n\\(2.5\\, \\mathrm{m}\\)\n\n\nIntensidad campo magnético\n\\(B_T\\)\n\\(25358\\,\\mathrm{nT}\\)\n\n\n\nEl error de las mediciones del IMU se calculan a partir de la densidad espectral del ruido informada en la hoja de datos, \\(S_{acc}\\) para el acelerómetro y \\(S_{gir}\\) para el giróscopo, y la frecuencia de muestreo \\(f_s\\)\n\\[\n\\sigma_{acc} = S_{acc} \\sqrt{fs}  \\qquad\n\\sigma_{acc} = S_{gir} \\sqrt{fs}\n\\]\nEl error del magnetómetro se calcula también a partir de su densidad espectral de ruido \\(S_{mag}\\) y su frecuencia de muestreo \\(f_s'\\), y también es afectado por la intensidad del campo magnético terrestre \\(B_T\\)\n\\[\n\\sigma_{mag} = \\frac{S_{mag} \\sqrt{fs'}}{B_T}\n\\]\nFialmente, el error del GPS no depende de la frecuencia de muestreo, y es informado diréctamente en la hoja de datos\n\n\nCódigo\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización de estado",
    "text": "Modelo de actualización de estado\nEn ausencia de aceleración, la evolución del estado en un tiempo \\(\\Delta t\\) seguiría un movimiento rectilíneo uniforme, dado por\n\\[\n\\mathbf{x}_k = \\begin{bmatrix}x_k \\\\ \\dot{x}_k \\\\ y_k \\\\ \\dot{y}_k \\\\ \\theta_k \\end{bmatrix} =\n\\begin{bmatrix}\n1 & \\Delta t & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & \\Delta t & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}x_{k-1} \\\\ \\dot{x}_{k-1} \\\\ y_{k-1} \\\\ \\dot{y}_{k-1} \\\\ \\theta_{k-1} \\end{bmatrix}\n\\]\nLa actualización del estado se hace en función de las mediciones de la IMU, que informan la aceleración del móvil en el sistema de referencia body, estas se modelan como el vector de medición \\(\\mathbf u\\) más el vector de error \\(\\mathbf w'\\)\nEstas aceleraciones se transladan al sistema de referencia inercial y se utilizan para realizar la actualización por modelo del filtro de Kalman, dada por medio de la ecuación\n\\[\n  \\mathbf{\\hat{x}}_k = A\\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{u}_{k-1} + \\mathbf{w}_{k-1}\n\\]\nEn donde la matriz \\(B_{k-1}\\) que obtiene la actualización del estado en el sistema inercial \\(\\mathbf{x}\\) en función de las mediciones de aceleración en el sistema body es dada por\n\\[\n  B_{k-1} = \\begin{bmatrix} \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                    - \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                    - \\Delta t \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\sin(\\theta_{k-1}) &\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      0 & 0 & \\Delta t\n  \\end{bmatrix}\n\\]\nY el ruido es similarmente transformado, obteniendo \\(\\mathbf{w}_{k-1} = B \\mathbf{w}_{k-1}'\\). La matriz de covarianza que resulta de la transformación es dada por\n\\[\n  Q_k = B Q B^T\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización por medición",
    "text": "Modelo de actualización por medición\nLa actualización por medición se basa en relacionar las mediciones del GPS y el magnetómetro con el estado actual \\(\\mathbf{\\hat{x}}\\) de la siguiente forma\n\\[\nH\\mathbf{\\hat{x}}_k = \\mathbf{z}_k + \\mathbf{v}_k\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1\n\\]\nY el vector de ruido tiene matriz de covarianza \\(R\\)\n\n\nCódigo\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "href": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "title": "TP2 - Filtros de Kalman",
    "section": "Algoritmo de estimación",
    "text": "Algoritmo de estimación\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n\nkalman_predict (generic function with 1 method)\n\n\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\n\nkalman_correct (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-imu",
    "href": "TP2_Filtro_Kalman.html#medición-del-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del IMU",
    "text": "Medición del IMU\nA cada instante de muestreo del IMU se obtiene un vector de mediciones \\(\\mathbf{\\overline{u}}_k\\), el cual se define como su valor real \\(\\mathbf{u}_k\\) más su error \\(\\mathbf{w'}_k\\)\n\\[\n  \\mathbf{\\overline{u}}_k =\n  \\mathbf{u}_k + \\mathbf{w}_k' = \\begin{bmatrix}u_k^{x_b} \\\\ u_k^{y_b} \\\\\n  u_k^{\\theta} \\end{bmatrix} + \\mathbf{w}_k'\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{w}'\\) es dada por\n\\[\n  Q = \\begin{bmatrix}\n    (\\sigma_{acc})^2 & 0 & 0\\\\\n    0 & (\\sigma_{acc})^2 & 0\\\\\n    0 & 0 & (\\sigma_{gir})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "href": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del GPS/Magnetómetro",
    "text": "Medición del GPS/Magnetómetro\nCuando \\(k\\) corresponde a un instante de muestreo del GPS, se obtiene un vector de mediciones \\(\\mathbf{\\overline{z}}_k\\), el cual se define como su valor real \\(\\mathbf{z}_k\\) más su error \\(\\mathbf{v}_k\\)\n\\[\n  \\mathbf{\\overline{z}}_k =\n  \\mathbf{z}_k + \\mathbf{v}_k = \\begin{bmatrix}z_k^{x} \\\\ z_k^{y} \\\\\n  z_k^{\\theta} \\end{bmatrix} + \\mathbf{v}_k\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{w}'\\) es dada por\n\\[\n  R = \\begin{bmatrix}\n    (\\sigma_{GPS})^2 & 0 & 0\\\\\n    0 & (\\sigma_{GPS})^2 & 0\\\\\n    0 & 0 & (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#inicialización",
    "href": "TP2_Filtro_Kalman.html#inicialización",
    "title": "TP2 - Filtros de Kalman",
    "section": "Inicialización",
    "text": "Inicialización\nLos valores de posición y orientación del estado \\(\\mathbf{\\hat{x}}\\) se inicializan con las primeras mediciones provenientes del GPS/magnetómetro. Los valores de velocidad se inicializan en \\(0\\).\nSe decide inicializar la matriz de covarianza con el error del GPS para la posición, el error del GPS multiplicado por la frecuencia de muestreo para la velocidad, y \\(2\\pi\\) para la orientación.\n\n\nCódigo\nfunction kalman_initialize(t, z, R)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([R[1,1]^2,(R[1,1]*fs2)^2,R[2,2]^2,(R[2,2]*fs2)^2,2pi])\n    K = zeros(N)\n    return x, P, K\nend\n\n\nkalman_initialize (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#predicción",
    "href": "TP2_Filtro_Kalman.html#predicción",
    "title": "TP2 - Filtros de Kalman",
    "section": "Predicción",
    "text": "Predicción\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P, Q)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n\nkalman_predict (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#corrección",
    "href": "TP2_Filtro_Kalman.html#corrección",
    "title": "TP2 - Filtros de Kalman",
    "section": "Corrección",
    "text": "Corrección\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior, R)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\n\nkalman_correct (generic function with 3 methods)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#móvil-estático",
    "href": "TP2_Filtro_Kalman.html#móvil-estático",
    "title": "TP2 - Filtros de Kalman",
    "section": "Móvil estático",
    "text": "Móvil estático\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo se encuentra en reposo.\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por\n\\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\", linestyle=:dash)\n    return p1\nend\n\nfunction trayectoria_xy(x, z_true, k_loss)\n    indices_sin_perdida = setdiff(1:size(x, 2), k_loss)\n    indices_antes_perdida = indices_sin_perdida[indices_sin_perdida .&lt; k_loss[1]]\n    indices_despues_perdida = indices_sin_perdida[indices_sin_perdida .&gt; k_loss[1]]\n    p1 = plot(x[1, indices_antes_perdida], x[3, indices_antes_perdida], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\", color=:black)\n    plot!(p1, z_true[1, :], z_true[2, :], label=\"Trayectoria\", linestyle=:dash)\n    plot!(p1, x[1, indices_despues_perdida], x[3, indices_despues_perdida], label=false, color=:black)\n    plot!(p1, x[1, k_loss], x[3, k_loss], aspect_ratio=:equal, label=\"Pérdida instrumento\")\n    return p1\nend\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:], linestyle=:dash)\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:], linestyle=:dash)\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi, linestyle=:dash)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\nfunction trayectoria_t(t, x, z_true, k_loss)\n    # Define los índices antes y después de la pérdida\n    indices_antes_perdida = 1:(k_loss[1] - 1)\n    indices_despues_perdida = (k_loss[end] + 1):length(t)\n    \n    p1 = plot(t[indices_antes_perdida], x[1, indices_antes_perdida], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\", color=:black)\n    plot!(p1, t, z_true[1, :], label=\"Trayectoria real\", linestyle=:dash)\n    plot!(p1, t[indices_despues_perdida], x[1, indices_despues_perdida], color=:black)\n    plot!(p1, t[k_loss], x[1, k_loss], label=\"Pérdida\")\n\n    p2 = plot(t[indices_antes_perdida], x[3, indices_antes_perdida], ylabel=\"y [m]\", color=:black)\n    plot!(p2, t, z_true[2, :], linestyle=:dash)\n    plot!(p2, t[indices_despues_perdida], x[3, indices_despues_perdida], color=:black)\n    plot!(p2, t[k_loss], x[3, k_loss], linestyle=:dash)\n\n    p3 = plot(t[indices_antes_perdida], x[5, indices_antes_perdida] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\", color=:black)\n    plot!(p3, t, z_true[3, :] .% 2pi, linestyle=:dash)\n    plot!(p3, t[indices_despues_perdida], x[5, indices_despues_perdida] .% 2pi, color=:black)\n    plot!(p3, t[k_loss], x[5, k_loss] .% 2pi)\n    \n    return plot(p1, p2, p3, layout=(3, 1), legend=false)\nend\n\n\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "href": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento rectilíneo uniformemente acelerado",
    "text": "Movimiento rectilíneo uniformemente acelerado\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo parte del reposo y sigue un movimiento rectilíneo uniformemente acelerado con aceleración \\(a\\) a un ángulo \\(\\theta\\) respecto a la horizontal.\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por \\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} a \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} \\frac 1 2 a t_k^2 \\cos(\\theta)  \\\\ \\frac 1 2 a t_k^2 \\sin(\\theta)  \\\\\n  \\theta \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction mrua_IMU(a)\n    return [a,0,0]\nend\nfunction mrua_GPS(a, t, θ)\n    return [1/2 * a * t^2 * cos(θ), 1/2 * a* t^2 * sin(θ), θ]\nend\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "href": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento circular uniforme",
    "text": "Movimiento circular uniforme\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo sigue un movimiento circular uniforme a un radio \\(r\\) del origen y con velocidad angular \\(\\omega\\).\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por \\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ \\omega^2 r \\\\\n  \\omega \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} r \\cos(\\omega t_k)  \\\\ r \\sin(\\omega t_k)  \\\\\n  \\omega t_k + \\frac \\pi 2 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#error-de-estimación",
    "href": "TP2_Filtro_Kalman.html#error-de-estimación",
    "title": "TP2 - Filtros de Kalman",
    "section": "Error de estimación",
    "text": "Error de estimación\nSe procede a cuantificar el error de la estimación, el cual se define como la norma cuadrática de la distancia entre la estimación y el valor real\n\\[\n\\epsilon_k = \\left\\lVert\\begin{bmatrix}\\hat{x}_k\\\\\\hat{y}_k\\end{bmatrix}-\n                        \\begin{bmatrix}z^x_k\\\\ z^y_k\\end{bmatrix}\\right\\rVert^2\n\\]\n\n\nCódigo\nfunction error_cuadratico(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\n\nerror_cuadratico (generic function with 1 method)\n\n\nEsto se compara con la incerteza del estimador, la cual se cuantifica con la traza de la matriz de covarianza \\(P\\)\n\n\nCódigo\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\n\nvarianza_estimador (generic function with 1 method)\n\n\nLos resultados verifican las observaciones, y se presentan a continuación\n\n\nCódigo\nfunction plot_error(t, x, z_true, P)\n    v = varianza_estimador(P)\n    e = error_cuadratico(x, z_true)\n    p1 = plot(t, v, ylim=[0, min(100,maximum(v)*1.1)], ylabel=\"Incerteza\")\n    p2 = plot(t, e, ylim=[0, 30], ylabel=\"Error cuadrático\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\nfunction plot_error(t, x, z_true, P, k_loss)\n    v = varianza_estimador(P)\n    e = error_cuadratico(x, z_true)\n    \n    indices_antes_perdida = 1:(k_loss[1] - 1)\n    indices_despues_perdida = (k_loss[end] + 1):length(t)\n    \n    p1 = plot(t[indices_antes_perdida], v[indices_antes_perdida], label=false, ylim=[0, min(100, maximum(v) * 1.1)], ylabel=\"Incerteza\", color=:black)\n    plot!(p1, t[indices_despues_perdida], v[indices_despues_perdida], label=false, color=:black)\n    plot!(p1, t[k_loss], v[k_loss], label=\"Pérdida Instrumento\")\n    \n    p2 = plot(t[indices_antes_perdida], e[indices_antes_perdida], ylim=[0, 30], label=false, ylabel=\"Error cuadrático\", xlabel=\"t\", color=:black)\n    plot!(p2, t[indices_despues_perdida], e[indices_despues_perdida], label=false, color=:black)\n    plot!(p2, t[k_loss], e[k_loss], label=\"Pérdida Instrumento\")\n    \n    return plot(p1, p2, layout=(2, 1))\nend\n\n\nplot_error(t, x, z_true, P)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#ganancia-de-kalman",
    "href": "TP2_Filtro_Kalman.html#ganancia-de-kalman",
    "title": "TP2 - Filtros de Kalman",
    "section": "Ganancia de Kalman",
    "text": "Ganancia de Kalman\nAdemás del error de medición, se analiza la evolución de la ganancia de Kalman \\(K_k\\) en función del tiempo. Esta se cuantifica como la norma de la matriz.\n\n\nCódigo\nfunction plot_gain(T, P, K)\n    k = findall(x -&gt; x!=0, K)\n    v = varianza_estimador(P)\n    p1 = plot(t, v, ylabel=\"Incerteza\", linetype=:steppost)\n    p2 = plot(t[k], K[k], ylim=[0, maximum(K)*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost)\n    return plot(p1, p2, layout=(2,1))\nend\nfunction plot_gain(t, P1, K1, P2, K2)\n    v1 = varianza_estimador(P1)\n    v2 = varianza_estimador(P2)\n    k1 = findall(x -&gt; x!=0, K1)\n    k2 = findall(x -&gt; x!=0, K2)\n    p1 = plot(t, v1, ylabel=\"Incerteza\", linetype=:steppost, label=false)\n    plot!(t, v2, ylabel=\"Incerteza\", linetype=:steppost, label=\"Referencia\")\n    p2 = plot(t[k1], K1[k1], ylim=[0, max(maximum(K1),maximum(K2))*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost, label=false)\n    plot!(t[k2], K2[k2], ylim=[0, max(maximum(K1),maximum(K2))*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost, label=\"Referencia\")\n    return plot(p1, p2, layout=(2,1))\nend\nplot_gain(t, P, K)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSe hace un foco en el estado estacionario del filtro, para observar como es afectada la incerteza del estimador y la ganacia de Kalman en los instantes en los que se registra una medición del GPS.\n\n\nCódigo\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-gps",
    "href": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incrementa x5 error de GPS",
    "text": "Incrementa x5 error de GPS\n\n\nCódigo\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\nR = [(5*err_GPS)^2 0 0; 0 (5*err_GPS)^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([-3.4394920738686467 -3.439502111004612 … 46.07636578603372 46.096347443328575; 0.0 -0.00020074271930193728 … 0.19996258036642386 0.19967056553076956; … ; 0.0 6.51236732354678e-5 … 0.18222834287508868 0.18242280284890053; 0.7854147984471791 0.7857580972350979 … 0.7857181174373654 0.7856102799360274], [24414.0625 0.0 … 0.0 0.0; 0.0 24414.0625 … 0.0 0.0; … ; 0.0 0.0 … 24414.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 24658.20312500016 2441.4062500032 … -3.2099294956666663e-26 0.0; 2441.4062500032 24414.062500064 … -2.5802684763794945e-24 0.0; … ; 1.853367632049536e-25 -2.33641367938908e-24 … 24414.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 25390.6250000016 4882.812500012799 … -1.6622050786788452e-25 0.0; 4882.812500012799 24414.062500128 … 1.1450525036193166e-25 0.0; … ; -7.945891993640974e-26 -2.2595703671633487e-24 … 24414.062500128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 1.7983434156211553 0.010073579143373998 … 2.9803947618920156e-21 0.0; 0.010073579143374 0.00011387555250521258 … 6.877033673281536e-23 0.0; … ; 9.36784477560193e-22 4.859063418418926e-24 … 0.00011387555250521258 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 1.779851291026657 0.009970091519782714 … 2.943967067457465e-21 0.0; 0.009970091519782716 0.00011329604483888592 … 6.899051859010421e-23 0.0; … ; 9.296537563001733e-22 7.279622785988886e-24 … 0.00011329604483888592 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 1.781846442451062 0.009981424324266602 … 2.950863878960033e-21 0.0; 0.009981424324266604 0.00011336004483888593 … 7.207746096192047e-23 0.0; … ; 9.303412386347986e-22 8.69725213156278e-24 … 0.00011336004483888593 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.9937032664305391 -1.1118054814223955e-33 0.0; 0.09838646202295398 -4.502771749120518e-30 0.0; … ; 7.459018778053517e-30 0.09838646202295398 0.0; 0.0 0.0 0.9999999752491497;;; 0.9938837920489301 -7.982894848290675e-33 0.0; 0.19113149847143707 -1.1877291444103766e-29 0.0; … ; -3.0312455583626435e-30 0.19113149847143707 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.011378438879881426 9.326277524946694e-22 0.0; 6.373732824825261e-5 1.8863669717431908e-23 0.0; … ; 5.944676389955704e-24 6.373732824825261e-5 0.0; 0.0 0.0 0.6968640780830011;;; 0.011391048262570605 9.363433308756971e-22 0.0; 6.380858572660938e-5 1.8904325630304056e-23 0.0; … ; 5.9497840403211095e-24 6.380858572660938e-5 0.0; 0.0 0.0 0.7122418117142865;;; 0.011275236495448655 9.190416722809555e-22 0.0; 6.316084098847408e-5 1.8676392619493602e-23 0.0; … ; 5.903826677495973e-24 6.316084098847408e-5 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([16.560507926131354 16.56048273500945 … 23.214386327741753 23.21800979458549; 0.0 -0.000503822438091478 … 0.036564643480589985 0.03590469339417032; … ; 0.0 -0.00014590240092825408 … 0.24864300005982656 0.24852474653195722; 1.5708129618446274 1.5724128976939822 … 7.853044950952963 7.854193750513061], [24414.0625 0.0 … 0.0 0.0; 0.0 24414.0625 … 0.0 0.0; … ; 0.0 0.0 … 24414.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 24658.20312500016 2441.4062500032 … -6.794641087770046e-30 0.0; 2441.4062500032 24414.062500064 … -1.482273948574e-28 0.0; … ; 7.36161531297499e-30 1.8788190870582313e-28 … 24414.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 25390.6250000016 4882.812500012799 … -1.2642509482127546e-28 0.0; 4882.812500012799 24414.062500128 … 1.0744126275138263e-27 0.0; … ; 1.8506810122132774e-28 -5.604429171187768e-27 … 24414.062500128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 1.7983434156211553 0.010073579143373998 … 2.323885916151569e-21 0.0; 0.010073579143374 0.00011387555250521258 … 1.6719174464086223e-23 0.0; … ; 9.793563520278315e-22 7.813230844076257e-24 … 0.00011387555250521258 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 1.779851291026657 0.009970091519782714 … 2.2865833833989183e-21 0.0; 0.009970091519782716 0.00011329604483888592 … 1.6417621031137142e-23 0.0; … ; 9.59395188794656e-22 7.679319780708543e-24 … 0.00011329604483888592 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 1.781846442451062 0.009981424324266602 … 2.2882242668637576e-21 0.0; 0.009981424324266604 0.00011336004483888593 … 1.6412333163901162e-23 0.0; … ; 9.601623310527678e-22 7.676933037744347e-24 … 0.00011336004483888593 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.9937032664305391 -1.2181463158708714e-37 0.0; 0.09838646202295398 -2.445539982441331e-34 0.0; … ; 2.952570795550858e-34 0.09838646202295398 0.0; 0.0 0.0 0.9999999752491497;;; 0.9938837920489301 -1.1168451294067755e-35 0.0; 0.19113149847143707 -4.233916538527272e-33 0.0; … ; 7.017686888333444e-33 0.19113149847143707 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.011378438879881426 1.2349953289533784e-21 0.0; 6.373732824825261e-5 1.4603654168833768e-23 0.0; … ; 6.1354191328241214e-24 6.373732824825261e-5 0.0; 0.0 0.0 0.6968640780830011;;; 0.011391048262570605 1.2378700509609218e-21 0.0; 6.380858572660938e-5 1.461377531884948e-23 0.0; … ; 6.140129208285797e-24 6.380858572660938e-5 0.0; 0.0 0.0 0.7122418117142865;;; 0.011275236495448655 1.2129731019029197e-21 0.0; 6.316084098847408e-5 1.4381908737292226e-23 0.0; … ; 6.016375528213683e-24 6.316084098847408e-5 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-imu",
    "href": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incrementa x5 error de IMU",
    "text": "Incrementa x5 error de IMU\n\n\nCódigo\nQ = [(5*err_IMU_x)^2 0 0; 0 (5*err_IMU_x)^2 0; 0 0 (5*err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([1.657026115968656 1.6569683441745213 … 43.51196929304563 43.52707475307199; 0.0 -0.001155435882689861 … 0.15156832473781592 0.150540875789427; … ; 0.0 -0.0004427808112365104 … 0.12490695286295499 0.12302345524436333; 0.7856076827056068 0.7859081781457461 … 0.78437459379551 0.786229415260439], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.453125004 3.90625008 … 8.20268254506302e-24 0.0; 3.90625008 39.0625016 … -2.1234806310617795e-23 0.0; … ; 4.717141712894731e-24 -5.17015364655269e-23 … 39.0625016 0.0; 0.0 0.0 … 0.0 6.2831859925687805;;; 40.62500004 7.812500320000001 … 7.401548198493395e-24 0.0; 7.812500320000001 39.062503199999995 … -4.0803279689868414e-23 0.0; … ; -7.41529726581395e-24 -2.7164458638921246e-23 … 39.062503199999995 0.0; 0.0 0.0 … 0.0 6.283186677957975;;; … ;;; 0.36169288198752264 0.01022958452947423 … -4.460279651733258e-21 0.0; 0.010229584529474227 0.0005721606635761616 … -2.7416341224901115e-22 0.0; … ; 1.0352229768229084e-20 5.302073886110996e-22 … 0.0005721606635761616 0.0; 0.0 0.0 … 0.0 6.320639916249882e-6;;; 0.34373920397192603 0.009721119932253367 … -4.113991983184087e-21 0.0; 0.009721119932253363 0.0005577606635760254 … -2.149090370601535e-22 0.0; … ; 9.552521562783446e-21 4.595199859865528e-22 … 0.0005577606635760254 0.0; 0.0 0.0 … 0.0 1.5213716556903334e-7;;; 0.3456890095650125 0.009776975998610968 … -4.131394791172145e-21 0.0; 0.009776975998610965 0.0005593606635760255 … -3.3788937005665313e-22 0.0; … ; 9.604179490798903e-21 5.130510676391246e-22 … 0.0005593606635760255 0.0; 0.0 0.0 … 0.0 8.375263600891277e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.863247863259832 6.481287762147712e-28 0.0; 0.08547008721303237 -1.590021713338593e-25 0.0; … ; 1.0378118202274625e-25 0.08547008721303237 0.0; 0.0 0.0 0.9999999752491522;;; 0.8666666667804445 1.5084271859684309e-27 0.0; 0.1666666733511111 -1.3069916996275953e-25 0.0; … ; -1.5345024145172726e-25 0.1666666733511111 0.0; 0.0 0.0 0.999999975249155;;; … ;;; 0.05470503370973201 -1.21759549988984e-20 0.0; 0.0015471959620724457 -6.508812350486445e-22 0.0; … ; 1.5219179179453685e-21 0.0015471959620724457 0.0; 0.0 0.0 0.9759866455818303;;; 0.05499827263550817 -1.229588572398899e-20 0.0; 0.0015553791891605383 -6.543575865697645e-22 0.0; … ; 1.5284034500453514e-21 0.0015553791891605383 0.0; 0.0 0.0 0.9782848225201974;;; 0.0524113567306914 -1.1158925396813386e-20 0.0; 0.0014823282274880575 -6.072793139207643e-22 0.0; … ; 1.4176916447789983e-21 0.0014823282274880575 0.0; 0.0 0.0 0.8433959372095443])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([21.657026115968655 21.656985128964074 … 19.583840323257903 19.583015704583257; 0.0 -0.0008197400916090282 … -0.00838958185317679 -0.008102791639699299; … ; 0.0 -0.0011801760329088887 … 0.18952330223381691 0.18741491341820157; 1.571005846103055 1.5725629786046302 … 7.8517014273111085 7.8548128858374735], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.453125004 3.90625008 … 3.3152438985746904e-27 0.0; 3.90625008 39.0625016 … 2.2708508249453298e-26 0.0; … ; 2.138819621918271e-28 -1.5101559122492603e-26 … 39.0625016 0.0; 0.0 0.0 … 0.0 6.2831859925687805;;; 40.62500004 7.812500320000001 … 1.879741133227766e-27 0.0; 7.812500320000001 39.062503199999995 … -2.0105971463364359e-25 0.0; … ; -1.6283665188125905e-27 3.9184689577891807e-25 … 39.062503199999995 0.0; 0.0 0.0 … 0.0 6.283186677957975;;; … ;;; 0.36169288198752264 0.01022958452947423 … 4.725851403315937e-22 0.0; 0.010229584529474227 0.0005721606635761616 … 1.1505303764174319e-22 0.0; … ; -2.7555457033360704e-22 -1.074771203261049e-22 … 0.0005721606635761616 0.0; 0.0 0.0 … 0.0 6.320639916249882e-6;;; 0.34373920397192603 0.009721119932253367 … 4.848230369404402e-22 0.0; 0.009721119932253363 0.0005577606635760254 … 1.1364851394990373e-22 0.0; … ; -2.909407826446147e-22 -1.0660214700845217e-22 … 0.0005577606635760254 0.0; 0.0 0.0 … 0.0 1.5213716556903334e-7;;; 0.3456890095650125 0.009776975998610968 … 4.9615572530552245e-22 0.0; 0.009776975998610965 0.0005593606635760255 … 1.1329496462625378e-22 0.0; … ; -3.016050049880594e-22 -1.0615281350079544e-22 … 0.0005593606635760255 0.0; 0.0 0.0 … 0.0 8.375263600891277e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.863247863259832 -1.6870240582935919e-31 0.0; 0.08547008721303237 -1.7470583380591837e-29 0.0; … ; 4.584277931641372e-30 0.08547008721303237 0.0; 0.0 0.0 0.9999999752491522;;; 0.8666666667804445 2.3630233245466158e-30 0.0; 0.1666666733511111 -9.46836365770524e-29 0.0; … ; -3.171909842620554e-29 0.1666666733511111 0.0; 0.0 0.0 0.999999975249155;;; … ;;; 0.05470503370973201 -2.674755954198545e-21 0.0; 0.0015471959620724457 6.979026470692419e-23 0.0; … ; -4.4936935617218365e-23 0.0015471959620724457 0.0; 0.0 0.0 0.9759866455818303;;; 0.05499827263550817 -2.660000542084261e-21 0.0; 0.0015553791891605383 7.150858086484715e-23 0.0; … ; -4.655052522313836e-23 0.0015553791891605383 0.0; 0.0 0.0 0.9782848225201974;;; 0.0524113567306914 -2.374929471227443e-21 0.0; 0.0014823282274880575 7.319770561249447e-23 0.0; … ; -4.849708322789433e-23 0.0014823282274880575 0.0; 0.0 0.0 0.8433959372095443])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#actualización-por-medición",
    "href": "TP2_Filtro_Kalman.html#actualización-por-medición",
    "title": "TP2 - Filtros de Kalman",
    "section": "Actualización por medición",
    "text": "Actualización por medición\nLa actualización por medición se basa en relacionar las mediciones del GPS y el magnetómetro con el estado actual \\(\\mathbf{\\hat{x}}\\) de la siguiente forma\n\\[\n\\mathbf{z}_k = H\\mathbf{\\hat{x}}_k - \\mathbf{v}_k\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nY el vector de ruido tiene matriz de covarianza \\(R\\)\n\n\nCódigo\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-gps",
    "href": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incremento x5 del error de GPS",
    "text": "Incremento x5 del error de GPS\nPrimero se analiza que sucede si el error del IMU se mantiene igual y el error del GPS incrementa 5 veces. Esto se realiza ejecutando el programa pero utilizando la siguiente matriz de covariaza para el ruido de medición\n\\[\n  R = \\begin{bmatrix}\n    (5\\sigma_{GPS})^2 & 0 & 0\\\\\n    0 & (5\\sigma_{GPS})^2 & 0\\\\\n    0 & 0 & (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]\nSe analiza las trayectorias rectilínea y circular, y los resultados se presentan a continuación.\n\nTrayectoria rectilínea\n\n\nCódigo\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\nR = [(5*err_GPS)^2 0 0; 0 (5*err_GPS)^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrayectoria circular\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nk1 = 4800\nk2 = 4850\nplot_gain(t[k1:k2], P2[:,:,k1:k2], K2[k1:k2], P[:,:,k1:k2], K[k1:k2])\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservaciones\n\nEl error de estimación es mucho mayor respecto al caso de referencia, en particular cerca del inicio de la trayectoria.\nEl filtro tarda mucho más tiempo en alcanzar el estado estacionario respecto al caso de referencia.\nA pesar que la incerteza de medición es mucho mayor, en el estado estacionario la ganancia de Kalman es similar a aquella del caso de referencia."
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-imu",
    "href": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incremento x5 del error de IMU",
    "text": "Incremento x5 del error de IMU\nA continuación se analiza que sucede si el error del IMU es el que incrementa 5 veces y el error del GPS se mantiene igual. Esto se realiza ejecutando el programa pero utilizando la siguiente matriz de covariaza para el ruido de modelo\n\\[\n  Q = \\begin{bmatrix}\n    (5\\sigma_{acc})^2 & 0 & 0\\\\\n    0 & (5\\sigma_{acc})^2 & 0\\\\\n    0 & 0 & (5\\sigma_{gir})^2\\\\\n  \\end{bmatrix}\n\\]\n\nTrayectoria rectilínea\n\n\nCódigo\nQ = [(5*err_IMU_x)^2 0 0; 0 (5*err_IMU_x)^2 0; 0 0 (5*err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrayectoria circular\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P2[:,:,k1:k2], K2[k1:k2], P[:,:,k1:k2], K[k1:k2])\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservaciones\n\nEl error de estimación es mayor respecto al caso de referencia, pero la diferencia no es tan drástica como en el caso que incrementa el error del GPS.\nNo se ve afectado el tiempo que tarda el filtro en alcanzar el estado estacionario respecto al caso de referencia.\nEl error de estimador es mayor respecto al caso de referencia, incluso en el estado estacionario.\nSe nota que la ganancia de Kalman es mayor respecto al caso de referencia. Esto implica que las mediciones del GPS se consideran más informativas."
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#pérdida-del-gps",
    "href": "TP2_Filtro_Kalman.html#pérdida-del-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Pérdida del GPS",
    "text": "Pérdida del GPS\nSuponemos la pérdida del GPS. En este caso la ecuación de acualización de estado se convierte en\n\\[\n  \\mathbf{z}_k' = H'\\mathbf{\\hat{x}}_k - \\mathbf{v}_k'\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH' =  \\begin{bmatrix}\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\]\n\\[\n  \\mathbf{z}_k' = \\begin{bmatrix} z_k^{\\theta} \\end{bmatrix}\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{v}'\\) es dada por\n\\[\n  R' = \\begin{bmatrix}\n   (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#pérdida-del-magnetómetro",
    "href": "TP2_Filtro_Kalman.html#pérdida-del-magnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Pérdida del magnetómetro",
    "text": "Pérdida del magnetómetro\nSuponemos la pérdida del GPS. En este caso la ecuación de acualización de estado se convierte en\n\\[\n  \\mathbf{z}_k'' = H''\\mathbf{\\hat{x}}_k - \\mathbf{v}_k''\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH'' =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0\n\\end{bmatrix}\n\\]\n\\[\n  \\mathbf{z}_k'' = \\begin{bmatrix} z_k^{x} \\\\ z_k^{y} \\end{bmatrix}\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{v}'\\) es dada por\n\\[\n  R'' = \\begin{bmatrix}\n   (\\sigma_{GPS})^2 & 0\\\\\n   0 & (\\sigma_{GPS})^2\n  \\end{bmatrix}\n\\]\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior, K, GPS=true, mag=true)\n  if GPS && mag\n    H2 = H\n    z2 = z\n    R2 = R\n  elseif mag\n    H2 = H[3,:]'\n    z2 = z[3]\n    R2 = R[3,3]\n  else\n    H2 = H[1:2, :]\n    z2 = z[1:2]\n    R2 = R[1:2,1:2]\n  end   \n  K = P_prior*H2'*inv(H2*P_prior*H2'+R2)\n  x_est = x_prior + K*(z2-H2*x_prior)\n  P_est = (I-K*H2)*P_prior\n  return x_est, P_est, K\nend\n\nfunction kalman(t, tasa_GPS, u, z, Q, R, gps, mag)\n    x, P, K = kalman_initialize(t, z, R)\n    K = zeros(size(t))\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1], Q)\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est, R, gps[k], mag[k])\n          K[k] = norm(K_k)\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P, K\nend\n\n\nkalman (generic function with 2 methods)\n\n\n\n\nCódigo\nQ = [(err_IMU_x)^2 0 0; 0 (err_IMU_x)^2 0; 0 0 (err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nk_loss = 2001:4000\n\ngps_sig = ones(size(t)) .|&gt; Bool\nmag_sig = ones(size(t)) .|&gt; Bool\ngps_sig[k_loss] = zeros(length(k_loss)) .|&gt; Bool\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, gps_sig, mag_sig)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P2, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ngps_sig = ones(size(t)) .|&gt; Bool\nmag_sig = ones(size(t)) .|&gt; Bool\nmag_sig[k_loss] = zeros(length(k_loss)) .|&gt; Bool\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, gps_sig, mag_sig)\n\n\n([20.664757889753602 20.66474285583983 … 20.398243667393647 20.39933417977401; 0.0 -0.0003006782754528369 … 0.011035808595077634 0.010774439012154798; … ; 0.0 -0.0001257062042887631 … 0.254140130236766 0.25405243058703625; 1.571407302312398 1.5727430215157154 … 7.852818325467154 7.853969395852709], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.45312500016 3.9062500032 … -1.1375733363018543e-28 0.0; 3.9062500032 39.062500064 … 4.185550368446819e-27 0.0; … ; -5.290969512267605e-29 -6.22579721666651e-27 … 39.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 40.6250000016 7.8125000128 … -1.5426668157884118e-28 0.0; 7.8125000128 39.062500127999996 … 1.0547947281613954e-26 0.0; … ; -1.5914423187275554e-27 -1.598557260040543e-26 … 39.062500127999996 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972723750735476 0.00202037050907998 … -1.1178284305226473e-21 0.0; 0.0020203705090799796 5.085414131495572e-5 … -3.0437642064072097e-23 0.0; … ; 2.429987686898165e-21 7.847266361459836e-23 … 5.085414131495572e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315593807332 0.0019748610285924453 … -1.0797913841859644e-21 0.0; 0.001974861028592445 5.027814126896574e-5 … -2.97200937411055e-23 0.0; … ; 2.3508528377139433e-21 7.693792214837593e-23 … 5.027814126896574e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.1565270345278644 0.0019798920427193415 … -1.0827628171337905e-21 0.0; 0.001979892042719341 5.034214126896574e-5 … -2.971517948693489e-23 0.0; … ; 2.3585470220101327e-21 7.694123637899888e-23 … 5.034214126896574e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.7623134290242808  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7131175945847074, 0.0])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P2, k_loss)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-ante-pérdida-del-gps",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-ante-pérdida-del-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización ante pérdida del GPS",
    "text": "Modelo de actualización ante pérdida del GPS\nSuponemos la pérdida del GPS. En este caso la ecuación de acualización de estado se convierte en\n\\[\n  \\mathbf{z}_k' = H'\\mathbf{\\hat{x}}_k - \\mathbf{v}_k'\n\\]\nEn donde el vector de actualización contiene únicamente los datos del magnetómetro, \\[\n  \\mathbf{z}_k' = \\begin{bmatrix} z_k^{\\theta} \\end{bmatrix}\n\\]\nLa matriz \\(H'\\) es dada por\n\\[\nH' =  \\begin{bmatrix}\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nY el error de medición \\(\\mathbf{v}'\\) tiene matriz de covarianza \\[\n  R' = \\begin{bmatrix}\n   (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-ante-pérdida-del-magnetómetro",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-ante-pérdida-del-magnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización ante pérdida del magnetómetro",
    "text": "Modelo de actualización ante pérdida del magnetómetro\nSuponemos la pérdida del GPS. En este caso la ecuación de acualización de estado se convierte en\n\\[\n  \\mathbf{z}_k'' = H''\\mathbf{\\hat{x}}_k - \\mathbf{v}_k''\n\\]\nEn donde el vector de actualización contiene únicamente los datos del GPS,\n\\[\n  \\mathbf{z}_k'' = \\begin{bmatrix} z_k^{x} \\\\ z_k^{y} \\end{bmatrix}\n\\]\nLa matriz \\(H''\\) es dada por\n\\[\nH'' =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0\n\\end{bmatrix}\n\\]\nY el error de medición \\(\\mathbf{v}''\\) tiene matriz de covarianza\n\\[\n  R'' = \\begin{bmatrix}\n   (\\sigma_{GPS})^2 & 0\\\\\n   0 & (\\sigma_{GPS})^2\n  \\end{bmatrix}\n\\]\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior, K, GPS=true, mag=true)\n  if GPS && mag\n    H2 = H\n    z2 = z\n    R2 = R\n  elseif mag\n    H2 = H[3,:]'\n    z2 = z[3]\n    R2 = R[3,3]\n  else\n    H2 = H[1:2, :]\n    z2 = z[1:2]\n    R2 = R[1:2,1:2]\n  end   \n  K = P_prior*H2'*inv(H2*P_prior*H2'+R2)\n  x_est = x_prior + K*(z2-H2*x_prior)\n  P_est = (I-K*H2)*P_prior\n  return x_est, P_est, K\nend\n\nfunction kalman(t, tasa_GPS, u, z, Q, R, gps, mag)\n    x, P, K = kalman_initialize(t, z, R)\n    K = zeros(size(t))\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1], Q)\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est, R, gps[k], mag[k])\n          K[k] = norm(K_k)\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P, K\nend\n\n\nkalman (generic function with 2 methods)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#simulación-de-pérdida-del-gps",
    "href": "TP2_Filtro_Kalman.html#simulación-de-pérdida-del-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Simulación de pérdida del GPS",
    "text": "Simulación de pérdida del GPS\nSe elige simular la trayectoria circular ya que esta es la más afectada por los datos de la medición de la orientación. A contiuación se presentan los resultados.\n\n\nCódigo\nQ = [(err_IMU_x)^2 0 0; 0 (err_IMU_x)^2 0; 0 0 (err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nk_loss = 2001:4000\n\ngps_sig = ones(size(t)) .|&gt; Bool\nmag_sig = ones(size(t)) .|&gt; Bool\ngps_sig[k_loss] = zeros(length(k_loss)) .|&gt; Bool\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, gps_sig, mag_sig)\n\n\n\nTrayectoria\n\n\nCódigo\ntrayectoria_xy(x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2, k_loss)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#simulación-de-pérdida-del-magnetómetro",
    "href": "TP2_Filtro_Kalman.html#simulación-de-pérdida-del-magnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Simulación de pérdida del magnetómetro",
    "text": "Simulación de pérdida del magnetómetro\nNuevamente se elige simular la trayectoria circular. A contiuación se presentan los resultados.\n\n\nCódigo\ngps_sig = ones(size(t)) .|&gt; Bool\nmag_sig = ones(size(t)) .|&gt; Bool\nmag_sig[k_loss] = zeros(length(k_loss)) .|&gt; Bool\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R, gps_sig, mag_sig)\n\n\n\nTrayectoria\n\n\nCódigo\ntrayectoria_xy(x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true, k_loss)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2, k_loss)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#observaciones-2",
    "href": "TP2_Filtro_Kalman.html#observaciones-2",
    "title": "TP2 - Filtros de Kalman",
    "section": "Observaciones",
    "text": "Observaciones\nSe nota que el efecto de la pérdida del GPS impacta mucho más sobre el desempeño del filtro de Kalman que la pérdida del magnetómetro. Esto se ve reflejado tanto en las gráficas de trayectoria y las de la cuantificación del error cuadrático medio."
  },
  {
    "objectID": "TP3_Modos_Flexibles.html",
    "href": "TP3_Modos_Flexibles.html",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "",
    "text": "Código\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport control as ct\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom scipy.signal import ellip, bessel, butter, cheby1\nimport seaborn as sns\nsns.set_theme()\nIs = 1069\nSe desarrollará un sistema de compensación LEAD-LAG que controle el ángulo \\(\\theta\\) con una entrada de torque \\(T\\). La transferencia del sistema puede representarse como\n\\[\n\\frac{\\theta(s)}{T(s)} = H_{sat}(s) H_{comp}(s) H_{LP}(s)\n\\]\nEn donde \\(H_{sat}(s)\\) es la transferencia del satélite, \\(H_{comp}(s)\\) es la transferencia del compensador LEAD-LAG, y \\(H_{LP}(s)\\) puede eventualmente ser la transferencia de un filtro pasa-bajo.\nCódigo\ndef get_TF(rm2=0.34, f2=0.3, k=3.17, filtro=False, fc=0.1):\n    sys_sat = satelite_TF(rm2, f2)\n    sys_leadlag = lead_lag_TF(k)\n    sys = sys_sat*sys_leadlag\n    if filtro:\n      n, d = cheby1(4, 1, fc, analog=True)\n      sys_filtro = ct.tf(n,d)\n      sys = sys*sys_filtro\n    return sys"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#modelo-del-satélite",
    "href": "TP3_Modos_Flexibles.html#modelo-del-satélite",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Modelo del satélite",
    "text": "Modelo del satélite\nEl satélite consiste en una estructura rígida más el aporte de apéndices flexibles, la antena y los paneles solares, su transferencia es dada por\n\\[\nH_{sat}(s) = H_S(s) H_{flex1}(s) H_{flex2}(s)\n\\]\nEn donde \\(H_S(s)\\) es dado por el momento de inercia de la estructura rígida\n\\[\nH_S(s) = \\frac{1}{I_S s^2}\n\\]\nY la contribución de los apéndices flexibles es dada por\n\\[\nH_{flex}(s) =  \\frac{I_S}{I_0} \\, \\frac{s^2+2 \\xi_Z \\omega_Z s + \\omega_Z^2}{s^2 + 2\\psi_{M} \\omega_{M} s + \\omega_{M}^2}\n\\]\nEn donde la relación entre momentos de inercia del satélite y el apéndice flexible recibe el nombre \\(R\\) y la frecuencia de cantilever del apéndice es \\(F_z\\). Estos factores se consideran variables para los paneles solares.\nA continuación se presentan diagramas de Bode y de Nichols del satélite ante diferentes valores de \\(F\\) y \\(R\\)\n\n\nCódigo\ndef satelite_TF(rm2=0.34, f2=0.3):\n    ns = 1\n    ds = np.array([Is, 0, 0])\n\n    tfS = ct.tf(ns,ds)\n\n    sys = tfS\n\n    rm1 = 0.04\n    I0 = Is*(1-rm1)\n\n    f1 = 2.0\n    psi1 = 0.001\n    w1 = 2*np.pi*f1\n\n    psi1m = psi1*np.sqrt(Is/I0)\n    w1m = w1*np.sqrt(Is/I0)\n\n    n1 = Is/I0*np.array([1, 2*psi1*w1, w1*w1])\n    d1 = np.array([1, 2*psi1m*w1m, w1m*w1m])\n\n    tf1 = ct.tf(n1,d1) \n    sys = sys * tf1\n\n    I0 = Is*(1-rm2)\n\n    psi2 = 0.001\n\n    w2 = 2*np.pi*f2\n    psi2m = psi2*np.sqrt(Is/I0)\n    w2m = w2*np.sqrt(Is/I0)\n\n    n2 = Is/I0*np.array([1, 2*psi2*w2, w2*w2])\n    d2 = np.array([1, 2*psi2m*w2m, w2m*w2m])\n\n    tf2 = ct.tf(n2,d2)\n    sys = sys * tf2\n    return sys\n\nfs =  [2*np.pi*1e-3, 2*np.pi*1e2]\nmag,phase,w = ct.bode(satelite_TF(0.5,1.0),fs,plot=True,Hz=True,dB=True,deg=True,label=\"F=1.0 Hz, R=0.5\")\nmag,phase,w = ct.bode(satelite_TF(0.5,0.1),fs,plot=True,Hz=True,dB=True,deg=True,label=\"F=0.1 Hz, R=0.5\")\nmag,phase,w = ct.bode(satelite_TF(0.1,1.0),fs,plot=True,Hz=True,dB=True,deg=True,label=\"F=1.0 Hz, R=0.1\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nct.nichols(satelite_TF(0.5,1.0),[0.01,10],label=\"F=1.0 Hz, R=0.5\")\nct.nichols(satelite_TF(0.5,0.1),[0.01,10],label=\"F=0.1 Hz, R=0.5\")\nct.nichols(satelite_TF(0.1,1.0),[0.01,10],label=\"F=1.0 Hz, R=0.1\")\nplt.show()"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#compensador",
    "href": "TP3_Modos_Flexibles.html#compensador",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Compensador",
    "text": "Compensador\nLa transferencia del compensador LEAD-LAG es dada por\n\\[\nH_C(s) = K \\frac{1}{s+1} \\frac{T_D s + 1 }{\\frac{1}{10}T_D s + 1}\n\\]\nEn donde \\(K\\) es la ganancia DC del compensador. El factor \\(T_D\\) depende de \\(K\\), por lo que este factor no solo la amplitud de la transferencia sino también su forma. La dependencia de \\(T_D\\) respecto a \\(K\\) es dada por la ecuación\n\\[\nT_D = 2\\xi\\sqrt{\\frac{I_S}{k}}\n\\]\nA continuación se presentan los diagramas de Bode de \\(H_C(s)\\) para diferentes valores de \\(K\\)\n\n\nCódigo\ndef lead_lag_TF(k=3.17):\n    psi = 1.\n    Wn = np.sqrt ( k/Is )\n    kd = 2*psi*Wn*Is\n    Td = kd/k\n\n    nc = np.array([k*Td, k])\n    dc = np.array([Td/10, 1])\n\n    tfC = ct.tf(nc,dc)\n    sys = tfC\n\n    Tdelay = 1\n    ndelay = 1\n    ddelay = np.array([Tdelay, 1])\n\n    tfDelay = ct.tf(ndelay,ddelay)\n\n    sys = sys*tfDelay\n    return sys\n\nmag,phase,w = ct.bode(lead_lag_TF(1),fs,plot=True,Hz=True,dB=True,deg=True,label=\"K=1\")\nmag,phase,w = ct.bode(lead_lag_TF(10),fs,plot=True,Hz=True,dB=True,deg=True,label=\"K=10\")\nmag,phase,w = ct.bode(lead_lag_TF(100),fs,plot=True,Hz=True,dB=True,deg=True,label=\"K=100\")\nplt.show()"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#optimización-del-factor-k",
    "href": "TP3_Modos_Flexibles.html#optimización-del-factor-k",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Optimización del factor \\(K\\)",
    "text": "Optimización del factor \\(K\\)\nPara diferentes valores de \\(R\\) y \\(F\\), se busca encontrar el \\(K\\) máximo que cumpla los siguientes requisitos de estabilidad\n\nMargen de fase a la frecuencia de crossover \\(f_{co}\\) mayor o igual a 30°\nGanancia del modo flexible menor a \\(-6 dB\\)\n\n\n\nCódigo\ndef findfirst(predicate, lst):\n    for i, val in enumerate(lst):\n        if predicate(val):\n            return i\n    return None  \n\ndef first_local_maximum(lst):\n    for i in range(1, len(lst) - 1):\n        if lst[i] &gt; lst[i - 1] and lst[i] &gt; lst[i + 1]:\n            return i \n    return None \n\ndef cumple_requisitos(rm2, f2, k):\n    sys = get_TF(rm2, f2, k)\n    mag,phase,w = ct.bode(sys,plot=False)\n    ico = findfirst(lambda x: x&lt;1, mag)\n    mag_dB = 10*np.log10(mag)\n    phase_deg = 180*phase/np.pi\n    phase_margin = abs(phase_deg[ico]+180)\n    imax = first_local_maximum(mag)\n    flex_gain = mag_dB[imax]\n    return flex_gain&lt;=-6 and phase_margin&gt;=30, w[ico]*2*np.pi, phase_margin, flex_gain\n\n\nSe propone utilizar una búsqueda binaria para automatizar la búsqueda del \\(K\\) máximo\n\n\nCódigo\ndef binary_search_predicate(predicate, low, high, tolerance=1e-3):\n    while high - low &gt; tolerance:\n        mid = np.sqrt(low * high)\n        if predicate(mid):\n            low = mid\n        else:\n            high = mid\n    return mid if predicate(mid) else low\n\n\nEl la frecuencia de cantilever de los paneles solares \\(F_p\\) varía entre 0,1 Hz y 1 Hz, mientras que la relación de su momento de inercia con el del satélite \\(R_p\\) varía entre 0,1 y 0,5.\nA continuación se presentan los resultados del \\(K\\) óptimo para diferentes combinaciones de \\(F_p\\) y \\(R_p\\), indicando además cual de los criterios de estabilidad es el factor limitante de \\(K\\).\n\n\n\n\n\n\n\n\n\n\n\n\\(F_p\\)\n\\(R_p\\)\n\\(f_{CO}\\)\n\\(K_{Max}\\)\nMargen de fase\nGanancia modo f.\n\n\n\n\n0,1 Hz\n0,1\n0,37 Hz\n1,02\n50,94°\n-6 dB\n\n\n0,1 Hz\n0,3\n0,25 Hz\n0,46\n25,04°\n-6 dB\n\n\n0,1 Hz\n0,5\n0,13 Hz\n0,12\n53,10°\n-6 dB\n\n\n0,5 Hz\n0,1\n2,88 Hz\n71,3\n30°\n-6,27 dB\n\n\n0,5 Hz\n0,3\n1,05 Hz\n8,30\n44,90°\n-6 dB\n\n\n0,5 Hz\n0,5\n1,32 Hz\n13,3\n42,53°\n-6 dB\n\n\n1,0 Hz\n0,1\n2,88 Hz\n71,1\n30°\n-15,1 dB\n\n\n1,0 Hz\n0,3\n1,05 Hz\n71,3\n30°\n-8,17 dB\n\n\n1,0 Hz\n0,5\n1,32 Hz\n71,4\n30°\n-9,76 dB\n\n\n\nSe observa que en ciertas situaciones el factor limitante es el margen de fase y en otras el factor limitante es la ganancia del modo flexible. A contiuación se presentan los diagramas de Bode y Nichols de ambos casos, uno limitado por el margen de fase y uno limitado por la ganancia del modo flexible."
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#resultado-para-f_p-1-text-hz-y-r_p-0.1",
    "href": "TP3_Modos_Flexibles.html#resultado-para-f_p-1-text-hz-y-r_p-0.1",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Resultado para \\(F_p = 1 \\text{ Hz}\\) y \\(R_p = 0.1\\)",
    "text": "Resultado para \\(F_p = 1 \\text{ Hz}\\) y \\(R_p = 0.1\\)\n\n\nCódigo\nfs =  [2*np.pi*1e-3, 2*np.pi*10]\nmag,phase,w = ct.bode(get_TF(0.1, 1.0, 71.18),fs,plot=True,Hz=True,dB=True,deg=True,title=\"Bode plot for F=1.0 Hz, R=0.1, K=71.18\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nct.nichols(get_TF(0.1, 1.0, 71.18),[0.01,10],label=\"F=1.0 Hz, R=0.1, K=71.18\")\nplt.show()"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#resultado-para-f_p-0.1-text-hz-y-r_p-0.5",
    "href": "TP3_Modos_Flexibles.html#resultado-para-f_p-0.1-text-hz-y-r_p-0.5",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Resultado para \\(F_p = 0.1 \\text{ Hz}\\) y \\(R_p = 0.5\\)",
    "text": "Resultado para \\(F_p = 0.1 \\text{ Hz}\\) y \\(R_p = 0.5\\)\n\n\nCódigo\nfs =  [2*np.pi*1e-3, 2*np.pi*10]\nmag,phase,w = ct.bode(get_TF(0.5, 0.1, 0.126),fs,plot=True,Hz=True,dB=True,deg=True,title=\"Bode plot for F=0.1 Hz, R=0.5, K=0.126\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nct.nichols(get_TF(0.5, 0.1, 0.126),[0.01,10],label=\"F=0.1 Hz, R=0.5, K=0.126\")\nplt.show()"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#incorporación-de-filtro-pasa-bajo",
    "href": "TP3_Modos_Flexibles.html#incorporación-de-filtro-pasa-bajo",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Incorporación de filtro pasa bajo",
    "text": "Incorporación de filtro pasa bajo\nA continuación se analiza el efecto de incorporar un filtro pasa bajo al sistema. Se considera razonable que el filtro rechaze la frecuencia de cantilever del modo flexible, por lo que se elige una frecuencia de corte \\(f_c\\) = 0,1 Hz.\nLuego de evaluar diferentes opciones, se opta por elegir un filtro Chebyshev tipo 1 con una tolerancia de 1 dB de ripple en la banda de paso.\n\n\nCódigo\nfs =  [2*np.pi*1e-3, 2*np.pi*10]\nn, d = cheby1(4, 1, 0.1, analog=True)\nsys_filtro = ct.tf(n,d)\nmag,phase,w = ct.bode(sys_filtro,fs,plot=True,Hz=True,dB=True,deg=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nLos resultados de máximo \\(K\\) cuando se incorpora el filtro al sistema se presentan a continuación\n\n\n\n\n\n\n\n\n\n\n\n\\(F_p\\)\n\\(R_p\\)\n\\(f_{CO}\\)\n\\(K_{Max}\\)\nMargen de fase\nGanancia modo f.\n\n\n\n\n0,1 Hz\n0,1\n1,32 Hz\n2753\n30°\n-16,4 dB\n\n\n0,1 Hz\n0,3\n1,30 Hz\n2772\n30°\n-17,0 dB\n\n\n0,1 Hz\n0,5\n1,30 Hz\n2840\n30°\n-16,4 dB\n\n\n0,5 Hz\n0,1\n1,32 Hz\n2753\n30°\n-61,0 dB\n\n\n0,5 Hz\n0,3\n1,32 Hz\n2753\n30°\n-53,5 dB\n\n\n0,5 Hz\n0,5\n1,32 Hz\n2753\n30°\n-57,9 dB\n\n\n1,0 Hz\n0,1\n1,32 Hz\n2753\n30°\n-80,1 dB\n\n\n1,0 Hz\n0,3\n1,32 Hz\n2753\n30°\n-75,0 dB\n\n\n1,0 Hz\n0,5\n1,32 Hz\n2753\n30°\n-79,1 dB\n\n\n\nAdemás, se presentan diagramas de Bode y Nichols del sistema, en el caso de \\(F_p\\) = 0,1 Hz y \\(R_p\\) = 0,1\n\n\nCódigo\nfs =  [2*np.pi*1e-3, 2*np.pi*10]\nmag,phase,w = ct.bode(get_TF(0.1, 0.1, 2753, True),fs,plot=True,Hz=True,dB=True,deg=True,title=\"Bode plot for F=0.1 Hz, R=0.1, K=2753, Lowpass\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nct.nichols(get_TF(0.1, 0.1, 2753, True),[0.01,10],label=\"F=0.1 Hz, R=0.1, K=2753, Lowpass\")\nplt.show()"
  },
  {
    "objectID": "TP3_Modos_Flexibles.html#conclusiones",
    "href": "TP3_Modos_Flexibles.html#conclusiones",
    "title": "TP3 - Control con Modos Flexibles",
    "section": "Conclusiones",
    "text": "Conclusiones\nEn presencia del filtro se observa que el factor limitante en todos los casos es el margen de fase, lo cual es de esperarse ya que la ganancia del modo flexible es rechazada por el filtro.\nAdemás, se observa que el \\(K\\) máximo posible es consistente para todas las combinaciones de \\(F_P\\) y \\(R_P\\) evaluadas, lo cual no sucedía en ausencia del filtro, y este valor de \\(K\\) es mucho mayor que los valores admisibles en la ausencia del filtro. Por estos motivos se concluye que la presencia del filtro incrementa el rendimieto del sistema.\nPara elegir el filtro, se buscó que este tenga una transición rápida a la banda de rechazo, para así rechazar la ganancia del modo flexible incluso cuando la fecuencia de cantilever está cerca de la frecuencia de corte del filtro. Los tipos de filtro con transición rápida a la banda de rechazo son el filtro elíptico y el filtro Chebyshev, sin embargo, el filtro elíptico tiene una alta distorsión de fase en la banda de paso, lo cual afecta drásticamente al criterio de estabilidad del margen de fase. Por estos motivos se consideró que el filtro Chebyshev es la mejor opción."
  },
  {
    "objectID": "TP3_Control_con_modos_flexibles.html",
    "href": "TP3_Control_con_modos_flexibles.html",
    "title": "SATE",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport control as ct\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\nIs = 1069\nns = 1\nds = np.array([Is, 0, 0])\n\ntfS = ct.tf(ns,ds)\n\n# Modo elastico de antena \n\nI0 = 1025\nf1 = 2.0\npsi1 = 0.001\n\nw1 = 2*np.pi*f1\npsi1m = psi1*np.sqrt(Is/I0)\nw1m = w1*np.sqrt(Is/I0)\n\nn1 = Is/I0*np.array([1, 2*psi1*w1,   w1*w1])\nd1 = np.array([1, 2*psi1m*w1m, w1m*w1m])\n \n# Modo elastico de los paneles solares\n \nI0 =300\nf2 = 0.3\npsi2 = 0.001\n\nw2 = 2*np.pi*f2\npsi2m = psi2*np.sqrt(Is/I0)\nw2m = w2*np.sqrt(Is/I0)\n\nn2 = Is/I0*np.array([1, 2*psi2*w2, w2*w2])\nd2 = np.array([1, 2*psi2m*w2m, w2m*w2m])\n\ntf1 = ct.tf(n1,d1)\ntf2 = ct.tf(n2,d2)\n\nprint(tf1)\nprint(tf2)\n\nsys = tf1*tf2*tfS\nsysCL = sys/(1+sys)\n\nmag,phase,omega =  ct.bode(sys,plot=True,Hz=False,dB=True,deg=True)\n\nct.nichols(sys,[0.001,10])\n\nT, yout = ct.step_response(sysCL,1000,1)\nplt.figure(figsize=(8,4))\nplt.plot(T,yout)\nplt.grid(color='k', ls = '-.', lw = 0.25)\nplt.xlabel(\"T\")\nplt.ylabel(\"yout\")\n\n&lt;TransferFunction&gt;: sys[1]\nInputs (1): ['u[0]']\nOutputs (1): ['y[0]']\n\n\n1.043 s^2 + 0.02621 s + 164.7\n-----------------------------\n   s^2 + 0.02621 s + 164.7\n\n&lt;TransferFunction&gt;: sys[2]\nInputs (1): ['u[0]']\nOutputs (1): ['y[0]']\n\n\n3.563 s^2 + 0.01343 s + 12.66\n-----------------------------\n   s^2 + 0.01343 s + 12.66\n\n\n\nText(0, 0.5, 'yout')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCONT\n\nIs = 1069\nk = 1\npsi = 1.0\n\nWn = np.sqrt ( k/Is )\nkd = 2*psi*Wn*Is\nTd = kd/k\n\nnc = np.array([k*Td, k])\ndc = np.array([Td/10, 1])\n\ntfC = ct.tf(nc,dc)\n\nTdelay = 1\nndelay = 1\nddelay = np.array([Tdelay, 1])\n\ntfDelay = ct.tf(ndelay, ddelay)\n\n\nsys = tfC*tfDelay\nsysCL = sys/(1+sys)\n\nct.bode(sys,Hz=False,dB=True,deg=True)\n\n\n\n\n\n\n\n\n\n\nFILT\n\nfrom scipy.signal import ellip, butter\n\n\nN1,D1 = ellip(4,2.,30,1.5,'low',analog=True)\nsys_F1 = ct.tf(N1,D1)\n\nN2,D2 = butter(1,2.5,'low',analog=True)\nsys_F2 = ct.tf(N2,D2)\n\n# Filtro NOTCH\nwc = 1.44\npsiz = 0.\npsip = 1.\nsys_F3=ct.tf([1, 2*psiz*wc, wc**2],[1, 2*psip*wc, wc**2])\n\nplt.figure()\nct.bode(sys_F1,Hz=False,dB=True,deg=True)\nprint(ct.margin(sys_F1))\nplt.figure()\nct.bode(sys_F2,Hz=False,dB=True,deg=True)\nprint(ct.margin(sys_F2))\nplt.figure()\nct.bode(sys_F3,Hz=False,dB=True,deg=True)\nprint(ct.margin(sys_F3))\n\n(np.float64(1.041276066342287), inf, np.float64(1.4000506631382332), nan)\n(inf, inf, nan, nan)\n(inf, inf, nan, nan)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTodo Junto\n\nFLEX = True\nFILTRO = False\nDELAY = True\n\n# Satelite \n\nIs = 1069\nns = 1\nds = np.array([Is, 0, 0])\n\ntfS = ct.tf(ns,ds)\n\nsys = tfS\n\n# La proporcion de Inercia aportada por el apendice flexible se regulara con la \n# constante rmi (i=1,2,...)\n# rmi = Inercia del Apendice flexible / Inercia total del satelite = Ia/Is\n# Por otro lado para calcular la frecuencia modal ( denominador de la funcion de \n# transferencia ) se necesitan Is y I0=Is-Ia\n# I0=Is-Ia=Is-rmi*Is=Is*(1-rmi)\n\n# Modo elastico de antena\n\nrm1 = 0.04\nI0 = Is*(1-rm1)\n\nf1 = 2.0\npsi1 = 0.001\nw1 = 2*np.pi*f1\n        \npsi1m = psi1*np.sqrt(Is/I0)\nw1m = w1*np.sqrt(Is/I0)\n\nn1 = Is/I0*np.array([1, 2*psi1*w1, w1*w1])\nd1 = np.array([1, 2*psi1m*w1m, w1m*w1m])\n\ntf1 = ct.tf(n1,d1) \n\nif True:\n    sys = sys * tf1\n    \n# Modo elastico de los paneles solares\n\nrm2 = 0.34          # Variar relacion de inercias rm2 entre (0.1 y 0.5)\nI0 = Is*(1-rm2)\n\nf2 = 0.3            # Variar frecuencia de cantilever entre (0.1 y 1.0)\npsi2 = 0.001\n\nw2 = 2*np.pi*f2\npsi2m = psi2*np.sqrt(Is/I0)\nw2m = w2*np.sqrt(Is/I0)\n\nn2 = Is/I0*np.array([1, 2*psi2*w2, w2*w2])\nd2 = np.array([1, 2*psi2m*w2m, w2m*w2m])\n\ntf2 = ct.tf(n2,d2)\n\nif FLEX:\n    sys = sys * tf2\n\n# LEAD-LAG\n\nk = 3.17        # Encontrar la ganancia k más grande que cumpla con los \n                # requerimientos para cada rm2 y f2\npsi = 1.\nWn = np.sqrt ( k/Is )\nkd = 2*psi*Wn*Is\nTd = kd/k\n\nnc = np.array([k*Td, k])\ndc = np.array([Td/10, 1])\n\ntfC = ct.tf(nc,dc)\nsys = sys * tfC\n\n# Delay\n\nTdelay = 1\nndelay = 1\nddelay = np.array([Tdelay, 1])\n\ntfDelay = ct.tf(ndelay,ddelay)\n\nif DELAY:\n    sys = sys*tfDelay\n\n# Filtro\n\n[N1,D1] = ellip(6,2.,10,1.5,'low',analog=True)\nsys_F1 = ct.tf(N1,D1)\n\nif FILTRO:\n    sys = sys*sys_F1\n\nsysCL=sys/(1+sys)\n\n\n# Analisis\n\nmag,phase,omega = ct.bode(sys,plot=True,Hz=False,dB=True,deg=True)\nct.nichols(sys,[0.001,10])\n\nT, yout = ct.step_response(sysCL,1000,.1)\nplt.figure(figsize=(8,4))\nplt.plot(T,yout)\nplt.grid(color='k', ls = '-.', lw = 0.25)\nplt.xlabel(\"T\")\nplt.ylabel(\"yout\")\n\nText(0, 0.5, 'yout')"
  }
]