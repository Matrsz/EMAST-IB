[
  {
    "objectID": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "href": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "title": "",
    "section": "",
    "text": "\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\]\nReemplazando 2 en 1:\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\]\nDespejando:\n\\[\n(Js^2  + C_d s + C_p) \\Theta(s) = C_p \\Theta_{ref}(s)\n\\]\nDe esta forma se verifica la función de transferencia\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{C_p}{Js^2  + C_d s + C_p}\n\\]\no bien,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\]\nPara relacionar esto con la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\)\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\]\nSe obtiene diréctamente\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}\n\\]\nAdemás,\n\\[\n\\frac{C_d}{J} = 2\\xi \\sqrt{\\frac{C_p}{J}} \\implies \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}\\]\nEn particular, con los valores dados en la tabla\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\)\n\\[\nC_p = \\omega_n^2J = 10 \\text{ kg m²/s²}\n\\]\n\\[\nC_d = 2\\xi\\omega_n J = 140 \\text{ kg m²/s}\n\\]\n\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J\n\nVamos con el grande…\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{LP1}(s)) + N_{LP2}(s)\\right)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{LP1}(s))\n\\]\nReemplazando:\n\\[\nJs^2\\Theta(s)-N_{LP1}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(s \\Theta(s) + N_{LP2}(s)\\right)\n\\]\nAgrupando a un lado:\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{LP3}(s) - C_dN_{LP2}(s) + N_{LP1}(s)\n\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\Theta(s) = \\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{LP3}(s) + \\frac{- C_d}{Js^2+C_d s + C_p}N_{LP2}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{LP1}(s)\n\\]\n\nimport scipy.signal as signal\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nH_1 = signal.TransferFunction([1], [J, C_d, C_p])\nH_2 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_3 = signal.TransferFunction([-C_p], [J, C_d, C_p])\n\nt_s = 1e-2\n\nN = 100000\n\ntheta_ref = np.random.normal(0, 1, N)\nt = np.linspace(0, N*t_s, N)\n\nT, theta1, _ = signal.lsim(H_1, theta_ref, t)\nT, theta2, _ = signal.lsim(H_2, theta_ref, t)\nT, theta3, _ = signal.lsim(H_3, theta_ref, t)\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, theta1)\nax[1].plot(T, theta2)\nax[2].plot(T, theta3)\n\n\n\n\n\n\n\n\n\nT, h1 = signal.impulse(H_1)\nT, h2 = signal.impulse(H_2)\nT, h3 = signal.impulse(H_3)\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, h1)\nax[1].plot(T, h2)\nax[2].plot(T, h3)\n\n\n\n\n\n\n\n\n\nf = np.fft.fftshift(np.fft.fftfreq(N, t_s))\npsd_N = np.array([1/t_s for x in f])\n\ndef H_1fun(f):\n    w = 2*np.pi*f\n    return 1/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_2fun(f):\n    w = 2*np.pi*f\n    return -C_d/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_3fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_1 = np.array([np.abs(H_1fun(fi))**2 for fi in f])*psd_N\nS_2 = np.array([np.abs(H_2fun(fi))**2 for fi in f])*psd_N\nS_3 = np.array([np.abs(H_3fun(fi))**2 for fi in f])*psd_N\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(f, S_1)\nax[1].plot(f, S_2)\nax[2].plot(f, S_3)\nfor i in [0,1,2]:\n    ax[i].set_xlim((-1,1))"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html",
    "href": "TP1_Propagación_Ruido_LTI.html",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "href": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "href": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Consideración de fuentes de ruido",
    "text": "Consideración de fuentes de ruido\nAl considerar las fuentes de ruido que alejan al comportamiento del sistema representado en la Figura 2 de su comportamiento ideal,\n\nWNTN2: Ruido de torque\nWNRS5: Ruido de velocidad\nWNPS8: Ruido de posición\n\nse obtiene el diagrama en bloques representado en la Figura 3.\n\n\n\n\n\n\nFigura 3: Diagrama de bloques del sistema considerando fuentes de ruido.\n\n\n\nLos ruidos se representan como ruido coloreado con frecuencia de corte \\(\\omega_C\\), y se expresan de la siguiente forma\n\\[\nN(s) = \\frac{\\omega_{c}}{s+\\omega_{c}}W(s)\n\\]\nEn donde \\(W(s)\\) es ruido blanco gausiano.\nIncorporando estos términos de ruido, la Ecuación 1 se convierte en la Ecuación 7,\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{P}(s)) + N_{V}(s)\\right)\n\\tag{7}\\]\nY la Ecuación 2 se convierte en la Ecuación 8,\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{P}(s))\n\\tag{8}\\]\nReemplazando la Ecuación 8 en la Ecuación 7 se obtiene\n\\[\nJs^2\\Theta(s)-N_{P}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(s \\Theta(s) + N_{V}(s)\\right)\n\\tag{9}\\]\nExpresando \\(\\Theta(s)\\) en función de los demás términos se obtiene\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{T}(s) - C_dN_{V}(s) + N_{P}(s)\n\\tag{10}\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\begin{aligned}\n\\Theta(s) = &\\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{11}\\]\nLa Ecuación 10 describe las contribuciones de la referencia a la posición angular, así como de los tres términos de ruido. Además, al cumplirse \\(\\dot{\\Theta}(s)=s\\Theta(s)\\), se obtiene la ecuación de la velocidad angular en función de sus contribuciones.\n\\[\n\\begin{aligned}\n\\dot{\\Theta}(s) = &\\frac{C_p s}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p s}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d s}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{s}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{12}\\]\nAplicando el principio de superposición, la Ecuación 11 y Ecuación 12 se pueden expresar de la siguiente forma\n\\[\n\\begin{aligned}\n\\Theta(s) = &H_{0}(s) \\Theta_{ref}(s) + H_{T0}(s)N_{T}(s) + H_{V0}(s)N_{V}(s) + H_{P0}(s)N_{P}(s)\\\\[1em]\n\\dot{\\Theta}(s) = &H_{1}(s) \\Theta_{ref}(s) + H_{T1}(s)N_{T}(s) + H_{V1}(s)N_{V}(s) + H_{P1}(s)N_{P}(s)\n\\end{aligned}\n\\tag{13}\\]\n\nEn donde las transferencias del ruido son \\[\n\\begin{matrix}\nH_{T0}(s) = \\dfrac{- C_p}{Js^2+C_d s + C_p}&\nH_{T1}(s) = \\dfrac{- C_p s}{Js^2+C_d s + C_p}\\\\\nH_{V0}(s) = \\dfrac{- C_d}{Js^2+C_d s + C_p}&\nH_{V1}(s) = \\dfrac{- C_d s}{Js^2+C_d s + C_p}\\\\\nH_{P0}(s) = \\dfrac{1}{Js^2+C_d s + C_p}&\nH_{P1}(s) = \\dfrac{s}{Js^2+C_d s + C_p}\\\\\n\\end{matrix}\n\\tag{14}\\]\n\n\nCódigo\nimport scipy.signal as signal\n\nH_t0 = signal.TransferFunction([-C_p], [J, C_d, C_p])\nH_v0 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_p0 = signal.TransferFunction([1], [J, C_d, C_p])\nH_t1 = signal.TransferFunction([-C_p, 0], [J, C_d, C_p])\nH_v1 = signal.TransferFunction([-C_d, 0], [J, C_d, C_p])\nH_p1 = signal.TransferFunction([1, 0], [J, C_d, C_p])\n\n\n\nRespuesta al Impulso\nSe procede a analizar las respuestas al impulso del sistema, dadas por\n\\[\nh_i(t) = \\mathcal{L}^{-1}\\left\\{H_i(s)\\right\\}\n\\]\nEstas se pueden calcular analíticamente, o bien utilizando scipy.signal.impulse. Los resultados se presentan en la Figura 4 y la Figura 5.\n\n\nCódigo\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_theme()\n\nT, h_t0 = signal.impulse(H_t0)\nT, h_v0 = signal.impulse(H_v0)\nT, h_p0 = signal.impulse(H_p0)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t0)\nax[1].plot(T, h_v0)\nax[2].plot(T, h_p0)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\theta$')\nax[0].set_ylabel(r'$h_{T0}$')\nax[1].set_ylabel(r'$h_{V0}$')\nax[2].set_ylabel(r'$h_{P0}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 4: Respuestas al impulso de las fuentes de ruido sobre la posición angular.\n\n\n\n\n\n\n\nCódigo\nT, h_t1 = signal.impulse(H_t1)\nT, h_v1 = signal.impulse(H_v1)\nT, h_p1 = signal.impulse(H_p1)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t1)\nax[1].plot(T, h_v1)\nax[2].plot(T, h_p1)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\dot\\theta$')\nax[0].set_ylabel(r'$h_{V1}$')\nax[1].set_ylabel(r'$h_{V1}$')\nax[2].set_ylabel(r'$h_{V1}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 5: Respuestas al impulso de las fuentes de ruido sobre la velocidad angular.\n\n\n\n\n\nLos resultados presentados en las figuras indican un estado transitorio de aproximadamente \\(50\\) s, lo cual da una noción de la escala temporal del sistema. Este resultado motiva la elección de un tiempo de muestreo de \\(T_s = 10\\) ms para realizar una simulación digital del sistema."
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "href": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Análisis de la respuesta del sistema ante ruido blanco",
    "text": "Análisis de la respuesta del sistema ante ruido blanco\nA partir de los gráficos de las respuestas al impulso presentados en la Figura 4 y Figura 5, así como las expresiones de las transferencias presentadas en la Ecuación 13, se determina que la respuesta del sistema ante las fuentes de ruido solo varía por un factor multiplicativo. Por este motivo se procede únicamente a analizar la respuesta al ruido de torque, sabiendo que el comportamiento ante el ruido de posición y el ruido de velocidad será similar.\n\nSimulación temporal\nPara simular la respuesta del sistema ante ruido blanco, se define una señal de entrada \\(n_T[t]\\) de \\(N\\) muestras independientes idénticamente distribuidas, definida por\n\\[\n  \\mathbf{n_T} \\sim \\mathcal{N}(\\mathbf 0_N, \\sigma^2 I_N)\n\\]\nA partir de esta señal se simulan las salidas, \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\), utilizando scipy.signal.lsim.\n\n\nCódigo\nimport numpy as np\n\nt_s = 1e-2\nvar_n = 100\nN = 400000\nt = np.linspace(0, N*t_s, N)\n\nn_t = np.random.normal(0, np.sqrt(var_n), N)\n\nT, pos, _ = signal.lsim(H_t0, n_t, t)\nT, vel, _ = signal.lsim(H_t1, n_t, t)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nfig.suptitle('Respuestas del sistema ante una entrada de ruido blanco', fontsize=16)\nax[0].plot(T, n_t)\nax[1].plot(T, pos)\nax[2].plot(T, vel)\nax[0].set_ylabel(r'$n_T$')\nax[1].set_ylabel(r'$\\theta$')\nax[2].set_ylabel(r'$\\dot\\theta$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(0,800)\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 6: Respuestas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nSe calcula el valor cuadrático medio empírico de las señales con la fórumla\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\frac{1}{N}\\sum_{t=0}^{N-1}x^2[t]\n\\]\nLos resultados para la realización vista en la Figura 6 se presentan a continuación\n\n\nCódigo\ndef round_sig_figs(value, sig_figs):\n    if value == 0:\n        return 0\n    else:\n        return round(value, sig_figs - int(np.floor(np.log10(abs(value)))) - 1)\n\nmsv_ruido = np.mean([n**2 for n in n_t])\nmsv_pos = np.mean([n**2 for n in pos])\nmsv_vel = np.mean([n**2 for n in vel])\n\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     99.9\nValor cuadrático medio de la posición angular:   0.0417\nValor cuadrático medio de la velocidad angular:  0.000401\n\n\n\n\nAnálisis en el dominio de la frecuencia\nSe procede a calcular la distribución espectral de potencia de \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\) ante la entrada \\(n_T[t]\\), a partir de la expresión teórica\n\\[\n\\begin{aligned}\nS_\\theta(f) &= \\left| H_{T0}(j2\\pi f) \\right|^2 S_{N_T}(f)\\\\\nS_{\\dot\\theta}(f) &= \\left| H_{T1}(j2\\pi f) \\right|^2 S_{N_T}(f)\n\\end{aligned}\n\\]\nEn donde \\(S_{n_T}\\) es la distribución espectral de potencia de ruido blanco con varianza \\(\\sigma^2\\) muestreado a una frecuencia \\(f_s = 1/T_S\\)\n\\[\n  S_{N_T}(f) = \\frac{\\sigma^2}{f_S} \\Pi\\left(\\frac{f}{f_S}\\right)\n\\]\n\n\nCódigo\nf = np.fft.fftfreq(N, t_s)\npsd_N = np.array([var_n*t_s for x in f])\n\ndef H_T0fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_T1fun(f):\n    w = 2*np.pi*f\n    return -C_p*(1j*w)/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_0 = np.array([np.abs(H_T0fun(fi))**2 for fi in f])*psd_N\nS_1 = np.array([np.abs(H_T1fun(fi))**2 for fi in f])*psd_N\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].loglog(f[0:N//2], psd_N[0:N//2])\nax[1].loglog(f[0:N//2], S_0[0:N//2])\nax[2].loglog(f[0:N//2], S_1[0:N//2])\nfig.suptitle('Distribución Espectral de Potencia')\nax[0].set_ylabel(r'$S_{N_T}$')\nax[1].set_ylabel(r'$S_{\\Theta}$')\nax[2].set_ylabel(r'$S_{\\dot\\Theta}$')\nax[2].set_xlabel(r'$f$ [Hz]')\nfor i in [0,1,2]:\n    ax[i].grid(True)\n\n\n\n\n\n\n\n\nFigura 7: Distribución espectral de potencia de las salidas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nLa Figura 7 indica que \\(H_{T0}\\) actúa como un filtro pasa bajo, mientras que \\(H_{T1}\\) actúa como un filtro pasa banda. Esto es consistente con un análisis cualitativo de las formas de onda presentadas en la Figura 6, así como de las tranferencias presentadas en la Ecuación 13.\nFinalmente, se calcula el valor cuadrático medio teórico de las señales, dado por\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\int_{-\\infty}^{\\infty} S_X(f) df\n\\]\nLos resultados utilizando integración numérica se presentan a continuación.\n\n\nCódigo\nf = np.fft.fftshift(f)\nS_0 = np.fft.fftshift(S_0)\nS_1 = np.fft.fftshift(S_1)\n\nmsv_ruido = np.trapezoid(psd_N, f)\nmsv_pos = np.trapezoid(S_0, f)\nmsv_vel = np.trapezoid(S_1, f)\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     100.0\nValor cuadrático medio de la posición angular:   0.0357\nValor cuadrático medio de la velocidad angular:  0.000357"
  },
  {
    "objectID": "kalman2.html",
    "href": "kalman2.html",
    "title": "",
    "section": "",
    "text": "using LinearAlgebra\nusing Distributions\nusing Plots\nusing ColorSchemes\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\n\nprintln(Q)\nprintln(R)\n\n[6.4000000000000006e-6 0.0 0.0; 0.0 6.4000000000000006e-6 0.0; 0.0 0.0 2.7415567780803773e-6]\n[6.25 0.0 0.0; 0.0 6.25 0.0; 0.0 0.0 1.5551418366801118e-7]\n\n\n\ndiagm([10,10,10])\n\n3×3 Matrix{Int64}:\n 10   0   0\n  0  10   0\n  0   0  10\n\n\n\n# Generadores de datos \n\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\n## Matrices filtro Kalman\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\n3×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  1\n\n\n\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\nfunction kalman_initialize(t, tasa_GPS, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N÷tasa_GPS)\n    return x, P, K\nend\n\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, tasa_GPS, z)\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est)\n            K[:,:,k÷tasa_GPS] = K_k\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P\nend\n\nkalman (generic function with 1 method)\n\n\n\nT = 500\nt = 0:0.1:T\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\nu = u_true + u_noise\nz = z_true + z_noise\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.22380275271364 … -0.17930100163669135 -0.1795083568166394; 0.0 -0.0003103366528196452 … -0.0018967979237825012 -0.002250305675178356; … ; 0.0 -0.00041613986353679247 … -0.0077613489996968725 -0.007801436660320887; -0.0002794640187689196 -0.00030817631756576455 … 2.2592111624671762e-5 -2.8431199440788638e-5], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.013290796118887e-28 0.0; 0.6250000032 6.250000064 … 2.4943584589793974e-28 0.0; … ; -7.088765594317273e-31 -4.395064373185345e-28 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … 7.38064560983693e-29 0.0; 1.2500000128000002 6.250000128 … 9.772577152374617e-28 0.0; … ; -6.938253732913538e-29 9.258807670461116e-28 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … 3.8033289446895193e-25 0.0; 0.002020370544845382 5.0854141278523966e-5 … -1.920307048984724e-26 0.0; … ; -3.9438733496621813e-26 2.854035111629257e-26 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … 3.6088972364073983e-25 0.0; 0.001974861075922868 5.027814120589553e-5 … -1.788868929978571e-26 0.0; … ; -3.379204849591105e-26 2.942533968508753e-26 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … 3.5909621971294503e-25 0.0; 0.001979892090043457 5.034214120589553e-5 … -1.78501228015534e-26 0.0; … ; -3.0856407044011273e-26 2.9440959920039314e-26 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t (generic function with 1 method)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\nfunction estimation_error(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\nfunction plot_error(t, x, z_true, P)\n    p1 = plot(t, varianza_estimador(P))\n    p2 = plot(t, estimation_error(x, z_true))\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction mru_IMU()\n    return [0,0,0]\nend\nfunction mru_GPS(v, t, θ)\n    return [v*t*cos(θ),v*t*sin(θ),θ]\nend\n\nmru_GPS (generic function with 1 method)\n\n\n\nt_gps = t[1:10:end]\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([mru_GPS(100/T, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.2237834951726105 … 70.58344470989839 70.59774251957364; 0.0 7.481416776940403e-5 … 0.143088907488292 0.14286728601674714; … ; 0.0 -0.0005136964710884169 … 0.13551697562445592 0.13523866163957277; 0.7851186993786794 0.7850899870798825 … 0.785420755509073 0.7853697321980075], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.1092301608009414e-25 0.0; 0.6250000032 6.250000064 … 3.9049200030955144e-25 0.0; … ; 1.9507123971656156e-25 1.1683928264965458e-24 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … -3.719139900271429e-26 0.0; 1.2500000128000002 6.250000128 … 8.275884030191062e-25 0.0; … ; 8.750696298758388e-26 4.391923111483954e-25 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … -1.8807255502262903e-21 0.0; 0.002020370544845382 5.0854141278523966e-5 … -6.360334456139304e-23 0.0; … ; 1.675403548287672e-21 2.937425523829086e-23 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … -1.8180632741629165e-21 0.0; 0.001974861075922868 5.027814120589553e-5 … -6.027221892540865e-23 0.0; … ; 1.61435427376303e-21 3.103030558032755e-23 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … -1.824114592005475e-21 0.0; 0.001979892090043457 5.034214120589553e-5 … -6.010226026335021e-23 0.0; … ; 1.6173663075581039e-21 3.152330368175671e-23 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\n3×5001 Matrix{Float64}:\n 18.7762    19.9011   24.5303    22.248    …  19.5701   19.6944   20.2105\n  0.739645  -3.65581  -0.937314   2.46585      2.6014   -3.40718  -2.94765\n  1.57052    1.57188   1.57352    1.57431      7.85118   7.85282   7.85396\n\n\n\nx, P = kalman(t, 10, u, z)\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)"
  },
  {
    "objectID": "kalman.html",
    "href": "kalman.html",
    "title": "",
    "section": "",
    "text": "function proceso_IMU(x, u, w, Δt)\n    θ = x[5]\n    A = [1 Δt 0 0 0;\n         0 1 0 0 0;\n         0 0 1 Δt 0;\n         0 0 0 1 0;\n         0 0 0 0 1]\n    B = [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n         Δt*cos(θ) -Δt*sin(θ) 0;\n         Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n         Δt*sin(θ) Δt*cos(θ) 0;\n         0 0 Δt]\n    return A*x+B*u+w\nend\n\nfunction medicion_gps(z, x, v)\n    H = [1 0 0 0 0;\n         0 0 1 0 0;\n         0 0 0 0 1]\n    return H*x+v\nend\n\nfunction matriz_B(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nx = [0, 1, 0, 1, 0]\nu = [1, 1, 1]\nw = [0, 0, 0, 0, 0]\n\nproceso_IMU(x, u, w, 1)\n\n5-element Vector{Float64}:\n 1.5\n 2.0\n 1.5\n 2.0\n 1.0\n\n\n\nΔt = 0.1\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\nfunction prediccion_kalman(A, x, B, u)\n    return A*x+B*u\nend\n\nM = [0.5^2 0 0;\n     0 0.5^2 0;\n     0 0 0.1^2]\n\n3×3 Matrix{Float64}:\n 0.25  0.0   0.0\n 0.0   0.25  0.0\n 0.0   0.0   0.01\n\n\n\n## Parametros\n\nerr_IMU_x = 0.1\nerr_IMU_θ = 0.01\n\nerr_GPS = 0.05\nerr_MAG = 0.005\n\nQ = [err_IMU_x^2 0 0;\n     0 err_IMU_x^2 0;\n     0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0;\n     0 err_GPS^2 0;\n     0 0 err_MAG^2]\n\n\n\n\n\n3×3 Matrix{Float64}:\n 0.0025  0.0     0.0\n 0.0     0.0025  0.0\n 0.0     0.0     2.5e-5\n\n\n\n## Estático\n\nusing Distributions\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nfunction estatico_IMU()\n    return [0,0,0] + rand(dist_ruido_IMU)\nend\nfunction estatico_GPS()\n    return [0,0,0] + rand(dist_ruido_GPS)\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\nusing OrderedCollections\n\nfunction datos(ts_IMU, ts_GPS, T, f_IMU, f_GPS)\n    t_IMU = 0:ts_IMU:T\n    t_GPS = 0:ts_GPS:T\n    med_IMU = zeros(3, length(t_IMU))\n    med_GPS = []\n    for ti in t\n        push!(med_IMU,f_IMU())\n        if ti%ts_GPS == 0\n            push!(med_GPS, f_GPS())\n            push!(t_GPS, ti)\n        end\n    end\n    return t_IMU, med_IMU, t_GPS, med_GPS\nend\n\nt_IMU, med_IMU, t_GPS, med_GPS = datos(0.1, 1, 10, estatico_IMU, estatico_GPS)\n\nUndefVarError: UndefVarError: `t` not defined\nUndefVarError: `t` not defined\n\n\n\nStacktrace:\n\n [1] datos(ts_IMU::Float64, ts_GPS::Int64, T::Int64, f_IMU::typeof(estatico_IMU), f_GPS::typeof(estatico_GPS))\n\n   @ Main ~/Documents/Maestria/Matemática Aplicada/Prácticas/TP2_Kalman/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W4sZmlsZQ==.jl:8\n\n [2] top-level scope\n\n   @ ~/Documents/Maestria/Matemática Aplicada/Prácticas/TP2_Kalman/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W4sZmlsZQ==.jl:18\n\n\n\nmed_IMU[:,1]\n\nUndefVarError: UndefVarError: `med_IMU` not defined\nUndefVarError: `med_IMU` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ ~/Documents/Maestria/Matemática Aplicada/Prácticas/TP2_Kalman/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W5sZmlsZQ==.jl:1\n\n\n\nmed_GPS\n\nUndefVarError: UndefVarError: `med_GPS` not defined\nUndefVarError: `med_GPS` not defined\n\n\n\nts = 0.1\nt = 0:0.1:10\n\nusing LinearAlgebra\nusing Plots\n\nx = zeros(5, length(t))\nP = zeros(5, 5, length(t))\n\nfor k in 2:length(t)\n    x_prev = x[:,k-1]\n    u = estatico_IMU()\n    B = B_matrix(x_prev[5])\n    x_est = A*x_prev + B*u\n    P_est = A*P[:,:,k-1]*A' + B*Q*B'\n    if k%10 == 0\n        z = estatico_GPS()\n        K = P_est*H'*inv(H*P_est*H'+R)\n        x_est = x_est + K*(z-H*x_est)\n        P_est = (I-K*H)*P_est\n    end\n    x[:,k] = x_est\n    P[:,:,k] = P_est\nend\n\n\np1 = plot(t, x[1,:])\np2 = plot(t, x[3,:])\np3 = plot(t, x[5,:])\n\nplot(p1,p2,p3, layout=(3,1))"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html",
    "href": "TP2_Filtro_Kalman.html",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\)."
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "href": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\)."
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "href": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "title": "TP2 - Filtros de Kalman",
    "section": "Error de los instrumentos",
    "text": "Error de los instrumentos\nPara cada dimensión de medición se considera su correspondiente error\n\n\nCódigo\nusing LinearAlgebra\nusing Distributions\nusing PlotThemes\nusing ColorSchemes\n\ntheme(:wong2)\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización de estado",
    "text": "Modelo de actualización de estado\nLa actualización del estado se hace en función de las mediciones de la IMU, que informan la aceleración del móvil en el sistema de referencia body, estas se modelan como el vector de medición \\(\\mathbf u\\) más el vector de error \\(\\mathbf w'\\)\nEstas aceleraciones se transladan al sistema de referencia inercial y se utilizan para realizar la actualización por modelo del filtro de Kalman, dada por medio de la ecuación\n\\[\n  \\mathbf{\\hat{x}}_k = A\\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{u}_{k-1} + \\mathbf{w}_{k-1}\n\\]\nEn donde la matriz \\(B_{k-1}\\) que obtiene la actualización del estado en el sistema inercial \\(\\mathbf{x}\\) en función de las mediciones de aceleración en el sistema body es dada por\n\\[\n  B_{k-1} = \\begin{bmatrix} \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                    - \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                    - \\Delta t \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\sin(\\theta_{k-1}) &\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      0 & 0 & \\Delta t\n  \\end{bmatrix}\n\\]\nY el ruido es similarmente transformado, obteniendo \\(\\mathbf{w}_{k-1} = B \\mathbf{w}_{k-1}'\\). La matriz de covarianza que resulta de la transformación es dada por\n\\[\n  Q_k = B Q B^T\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización por medición",
    "text": "Modelo de actualización por medición\n\n\nCódigo\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "href": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "title": "TP2 - Filtros de Kalman",
    "section": "Algoritmo de estimación",
    "text": "Algoritmo de estimación\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n\nkalman_predict (generic function with 1 method)\n\n\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\n\nkalman_correct (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-imu",
    "href": "TP2_Filtro_Kalman.html#medición-del-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del IMU",
    "text": "Medición del IMU\nA cada instante de muestreo del IMU se obtiene un vector de mediciones \\(\\mathbf{\\overline{u}}_k\\), el cual se define como su valor real \\(\\mathbf{u}_k\\) más su error \\(\\mathbf{w'}_k\\)\n\\[\n  \\mathbf{\\overline{u}}_k =\n  \\mathbf{u}_k + \\mathbf{w}_k' = \\begin{bmatrix}u_k^{x_b} \\\\ u_k^{y_b} \\\\\n  u_k^{\\theta} \\end{bmatrix} + \\mathbf{w}_k'\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{w}'\\) es dada por\n\\[\n  Q = \\begin{bmatrix}\n    (\\sigma^{x_b})^2 & 0 & 0\\\\\n    0 & (\\sigma^{x_b})^2 & 0\\\\\n    0 & 0 & (\\sigma^\\theta)^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "href": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del GPS/Magnetómetro",
    "text": "Medición del GPS/Magnetómetro\nCuando \\(k\\) corresponde a un instante de muestreo del GPS, se obtiene un vector de mediciones \\(\\mathbf{\\overline{z}}_k\\), el cual se define como su valor real \\(\\mathbf{z}_k\\) más su error \\(\\mathbf{v}_k\\)\n\\[\n  \\mathbf{\\overline{z}}_k =\n  \\mathbf{z}_k + \\mathbf{v}_k = \\begin{bmatrix}z_k^{x} \\\\ z_k^{y} \\\\\n  z_k^{\\theta} \\end{bmatrix} + \\mathbf{v}_k\n\\]\nEn ausencia de aceleración, la evolución del estado en un tiempo \\(\\Delta t\\) seguiría un movimiento rectilíneo uniforme, dado por\n\\[\n\\mathbf{x}_k = \\begin{bmatrix}x_k \\\\ \\dot{x}_k \\\\ y_k \\\\ \\dot{y}_k \\\\ \\theta_k \\end{bmatrix} =\n\\begin{bmatrix}\n1 & \\Delta t & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & \\Delta t & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}x_{k-1} \\\\ \\dot{x}_{k-1} \\\\ y_{k-1} \\\\ \\dot{y}_{k-1} \\\\ \\theta_{k-1} \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#inicialización",
    "href": "TP2_Filtro_Kalman.html#inicialización",
    "title": "TP2 - Filtros de Kalman",
    "section": "Inicialización",
    "text": "Inicialización\n\n\nCódigo\nfunction kalman_initialize(t, tasa_GPS, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N÷tasa_GPS)\n    return x, P, K\nend\n\n\nkalman_initialize (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#predicción",
    "href": "TP2_Filtro_Kalman.html#predicción",
    "title": "TP2 - Filtros de Kalman",
    "section": "Predicción",
    "text": "Predicción\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n\nkalman_predict (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#corrección",
    "href": "TP2_Filtro_Kalman.html#corrección",
    "title": "TP2 - Filtros de Kalman",
    "section": "Corrección",
    "text": "Corrección\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\n\nkalman_correct (generic function with 1 method)\n\n\n\n\nCódigo\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, tasa_GPS, z)\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est)\n            K[:,:,k÷tasa_GPS] = K_k\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P, K\nend\n\n\nkalman (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#móvil-estático",
    "href": "TP2_Filtro_Kalman.html#móvil-estático",
    "title": "TP2 - Filtros de Kalman",
    "section": "Móvil estático",
    "text": "Móvil estático\n\\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\]\n\\[\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n\n\nCódigo\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "href": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento rectilíneo uniformemente acelerado",
    "text": "Movimiento rectilíneo uniformemente acelerado\n\\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} a \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\]\n\\[\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} \\frac 1 2 a t_k^2 \\cos(\\theta)  \\\\ \\frac 1 2 a t_k^2 \\sin(\\theta)  \\\\\n  \\theta \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction mrua_IMU(a)\n    return [a,0,0]\nend\nfunction mrua_GPS(a, t, θ)\n    return [1/2 * a * t^2 * cos(θ), 1/2 * a* t^2 * sin(θ), θ]\nend\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "href": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento circular uniforme",
    "text": "Movimiento circular uniforme\n\\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ \\omega^2 r \\\\\n  \\omega \\end{bmatrix} + \\mathbf{w}_k'\n\\]\n\\[\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} r \\cos(\\omega t_k)  \\\\ r \\sin(\\omega t_k)  \\\\\n  \\omega t_k + \\frac \\pi 2 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  }
]