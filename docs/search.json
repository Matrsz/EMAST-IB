[
  {
    "objectID": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "href": "TP1_Propagacion_Ruido_Sistemas_LTI.html",
    "title": "",
    "section": "",
    "text": "\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\]\nReemplazando 2 en 1:\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\]\nDespejando:\n\\[\n(Js^2  + C_d s + C_p) \\Theta(s) = C_p \\Theta_{ref}(s)\n\\]\nDe esta forma se verifica la función de transferencia\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{C_p}{Js^2  + C_d s + C_p}\n\\]\no bien,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\]\nPara relacionar esto con la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\)\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\]\nSe obtiene diréctamente\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}\n\\]\nAdemás,\n\\[\n\\frac{C_d}{J} = 2\\xi \\sqrt{\\frac{C_p}{J}} \\implies \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}\\]\nEn particular, con los valores dados en la tabla\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\)\n\\[\nC_p = \\omega_n^2J = 10 \\text{ kg m²/s²}\n\\]\n\\[\nC_d = 2\\xi\\omega_n J = 140 \\text{ kg m²/s}\n\\]\n\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J\n\nVamos con el grande…\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{LP1}(s)) + N_{LP2}(s)\\right)\n\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{LP1}(s))\n\\]\nReemplazando:\n\\[\nJs^2\\Theta(s)-N_{LP1}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{LP3}(s)) - C_d \\left(s \\Theta(s) + N_{LP2}(s)\\right)\n\\]\nAgrupando a un lado:\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{LP3}(s) - C_dN_{LP2}(s) + N_{LP1}(s)\n\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\Theta(s) = \\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{LP3}(s) + \\frac{- C_d}{Js^2+C_d s + C_p}N_{LP2}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{LP1}(s)\n\\]\n\nimport scipy.signal as signal\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nH_1 = signal.TransferFunction([1], [J, C_d, C_p])\nH_2 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_3 = signal.TransferFunction([-C_p], [J, C_d, C_p])\n\nt_s = 1e-2\n\nN = 100000\n\ntheta_ref = np.random.normal(0, 1, N)\nt = np.linspace(0, N*t_s, N)\n\nT, theta1, _ = signal.lsim(H_1, theta_ref, t)\nT, theta2, _ = signal.lsim(H_2, theta_ref, t)\nT, theta3, _ = signal.lsim(H_3, theta_ref, t)\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, theta1)\nax[1].plot(T, theta2)\nax[2].plot(T, theta3)\n\n\n\n\n\n\n\n\n\nT, h1 = signal.impulse(H_1)\nT, h2 = signal.impulse(H_2)\nT, h3 = signal.impulse(H_3)\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(T, h1)\nax[1].plot(T, h2)\nax[2].plot(T, h3)\n\n\n\n\n\n\n\n\n\nf = np.fft.fftshift(np.fft.fftfreq(N, t_s))\npsd_N = np.array([1/t_s for x in f])\n\ndef H_1fun(f):\n    w = 2*np.pi*f\n    return 1/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_2fun(f):\n    w = 2*np.pi*f\n    return -C_d/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_3fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_1 = np.array([np.abs(H_1fun(fi))**2 for fi in f])*psd_N\nS_2 = np.array([np.abs(H_2fun(fi))**2 for fi in f])*psd_N\nS_3 = np.array([np.abs(H_3fun(fi))**2 for fi in f])*psd_N\n\n\nfig, ax = plt.subplots(3,1)\nax[0].plot(f, S_1)\nax[1].plot(f, S_2)\nax[2].plot(f, S_3)\nfor i in [0,1,2]:\n    ax[i].set_xlim((-1,1))"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html",
    "href": "TP1_Propagación_Ruido_LTI.html",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "href": "TP1_Propagación_Ruido_LTI.html#descripción-del-problema",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "",
    "text": "Se analizará un sistema de control de la orientación de un satélite tal como es representado en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEl sistema de control se representa como diagrama de bloques como se ve en la Figura 2.\n\n\n\n\n\n\nFigura 2: Diagrama en bloques del sistema sin ruido.\n\n\n\nEn donde \\(\\theta_{ref}\\) es la entrada, y \\(\\theta\\) la salida. Para encontrar la función de transferencia se plantean las ecuaciones\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - \\frac{C_d}{Js}T_c(s)\n\\tag{1}\\]\n\\[\n\\Theta(s) = \\frac{1}{Js^2} T_c(s)\n\\tag{2}\\]\nReemplazando la Ecuación 2 en la Ecuación 1 se obtiene la expresión\n\\[\nJs^2 \\Theta(s) = C_p (\\Theta_{ref}(s) - \\Theta(s)) - C_d s \\Theta(s)\n\\tag{3}\\]\nLa cual se despeja para obtener la función de transferencia,\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\frac{C_p}{J}}{s^2  + \\frac{C_d}{J} s + \\frac{C_p}{J}}\n\\tag{4}\\]\n\n\nLa Ecuación 4 expresa la transferencia en función de los factores \\(C_p\\) y \\(C_d\\). Esta expresión es equivalente a la transferencia expresada en función de la frecuencia natural \\(\\omega_n\\) y el factor de amortiguamiento \\(\\xi\\),\n\\[\n\\frac{\\Theta(s)}{\\Theta_{ref}(s)}  = \\frac{\\omega_n^2}{s^2  + 2\\xi\\omega_n s + \\omega_n^2}\n\\tag{5}\\]\nAl comparar la Ecuación 4 con la Ecuación 5 es fácil ver que la relación entre los parámetros es dada por\n\\[\n\\omega_n = \\sqrt{\\frac{C_p}{J}}, \\qquad \\xi = \\frac{1}{2}\\frac{C_d}{\\sqrt{JC_p}}.\n\\tag{6}\\]\nSi se consideran los valores dados en la tabla\n\n\n\nTabla 1: Datos del problema\n\n\n\n\n\nParámetro\nValor\n\n\n\n\n\\(J\\)\n1000 [kg m²]\n\n\n\\(\\omega_n\\)\n0,1 [rad/s]\n\n\n\\(\\xi\\)\n0,7\n\n\n\n\n\n\nSe obtienen los valores de \\(C_d\\) y \\(C_p\\),\n\n\n\nTabla 2: Parámetros del sistema calculados a partir de los datos del problema\n\n\n\n\n\nParámetro\nFórmula\nValor\n\n\n\n\n\\(C_p\\)\n\\(\\omega_n^2J\\)\n10 [kg m²/s²]\n\n\n\\(C_d\\)\n\\(2\\xi\\omega_n J\\)\n140 [kg m²/s]\n\n\n\n\n\n\n\n\nCódigo\nJ = 1000\nw_n = 0.1\nxi = 0.7\n\nC_p = w_n**2*J\nC_d = 2*xi*w_n*J"
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "href": "TP1_Propagación_Ruido_LTI.html#consideración-de-fuentes-de-ruido",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Consideración de fuentes de ruido",
    "text": "Consideración de fuentes de ruido\nAl considerar las fuentes de ruido que alejan al comportamiento del sistema representado en la Figura 2 de su comportamiento ideal,\n\nWNTN2: Ruido de torque\nWNRS5: Ruido de velocidad\nWNPS8: Ruido de posición\n\nse obtiene el diagrama en bloques representado en la Figura 3.\n\n\n\n\n\n\nFigura 3: Diagrama de bloques del sistema considerando fuentes de ruido.\n\n\n\nLos ruidos se representan como ruido coloreado con frecuencia de corte \\(\\omega_C\\), y se expresan de la siguiente forma\n\\[\nN(s) = \\frac{\\omega_{c}}{s+\\omega_{c}}W(s)\n\\]\nEn donde \\(W(s)\\) es ruido blanco gausiano.\nIncorporando estos términos de ruido, la Ecuación 1 se convierte en la Ecuación 7,\n\\[\nT_c(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(\\frac{1}{Js}(T_c(s)+N_{P}(s)) + N_{V}(s)\\right)\n\\tag{7}\\]\nY la Ecuación 2 se convierte en la Ecuación 8,\n\\[\n\\Theta(s) = \\frac{1}{Js^2} (T_c(s)+N_{P}(s))\n\\tag{8}\\]\nReemplazando la Ecuación 8 en la Ecuación 7 se obtiene\n\\[\nJs^2\\Theta(s)-N_{P}(s) = C_p (\\Theta_{ref}(s) - \\Theta(s) - N_{T}(s)) - C_d \\left(s \\Theta(s) + N_{V}(s)\\right)\n\\tag{9}\\]\nExpresando \\(\\Theta(s)\\) en función de los demás términos se obtiene\n\\[\n(Js^2+C_d s + C_p)\\Theta(s) = C_p \\Theta_{ref}(s) - C_pN_{T}(s) - C_dN_{V}(s) + N_{P}(s)\n\\tag{10}\\]\nFinalmente, esto se puede expresar de la siguiente forma.\n\\[\n\\begin{aligned}\n\\Theta(s) = &\\frac{C_p}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{1}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{11}\\]\nLa Ecuación 10 describe las contribuciones de la referencia a la posición angular, así como de los tres términos de ruido. Además, al cumplirse \\(\\dot{\\Theta}(s)=s\\Theta(s)\\), se obtiene la ecuación de la velocidad angular en función de sus contribuciones.\n\\[\n\\begin{aligned}\n\\dot{\\Theta}(s) = &\\frac{C_p s}{Js^2+C_d s + C_p} \\Theta_{ref}(s) + \\frac{- C_p s}{Js^2+C_d s + C_p}N_{T}(s)\\\\ &+ \\frac{- C_d s}{Js^2+C_d s + C_p}N_{V}(s) + \\frac{s}{Js^2+C_d s + C_p}N_{P}(s)\n\\end{aligned}\n\\tag{12}\\]\nAplicando el principio de superposición, la Ecuación 11 y Ecuación 12 se pueden expresar de la siguiente forma\n\\[\n\\begin{aligned}\n\\Theta(s) = &H_{0}(s) \\Theta_{ref}(s) + H_{T0}(s)N_{T}(s) + H_{V0}(s)N_{V}(s) + H_{P0}(s)N_{P}(s)\\\\[1em]\n\\dot{\\Theta}(s) = &H_{1}(s) \\Theta_{ref}(s) + H_{T1}(s)N_{T}(s) + H_{V1}(s)N_{V}(s) + H_{P1}(s)N_{P}(s)\n\\end{aligned}\n\\tag{13}\\]\n\nEn donde las transferencias del ruido son \\[\n\\begin{matrix}\nH_{T0}(s) = \\dfrac{- C_p}{Js^2+C_d s + C_p}&\nH_{T1}(s) = \\dfrac{- C_p s}{Js^2+C_d s + C_p}\\\\\nH_{V0}(s) = \\dfrac{- C_d}{Js^2+C_d s + C_p}&\nH_{V1}(s) = \\dfrac{- C_d s}{Js^2+C_d s + C_p}\\\\\nH_{P0}(s) = \\dfrac{1}{Js^2+C_d s + C_p}&\nH_{P1}(s) = \\dfrac{s}{Js^2+C_d s + C_p}\\\\\n\\end{matrix}\n\\tag{14}\\]\n\n\nCódigo\nimport scipy.signal as signal\n\nH_t0 = signal.TransferFunction([-C_p], [J, C_d, C_p])\nH_v0 = signal.TransferFunction([-C_d], [J, C_d, C_p])\nH_p0 = signal.TransferFunction([1], [J, C_d, C_p])\nH_t1 = signal.TransferFunction([-C_p, 0], [J, C_d, C_p])\nH_v1 = signal.TransferFunction([-C_d, 0], [J, C_d, C_p])\nH_p1 = signal.TransferFunction([1, 0], [J, C_d, C_p])\n\n\n\nRespuesta al Impulso\nSe procede a analizar las respuestas al impulso del sistema, dadas por\n\\[\nh_i(t) = \\mathcal{L}^{-1}\\left\\{H_i(s)\\right\\}\n\\]\nEstas se pueden calcular analíticamente, o bien utilizando scipy.signal.impulse. Los resultados se presentan en la Figura 4 y la Figura 5.\n\n\nCódigo\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_theme()\n\nT, h_t0 = signal.impulse(H_t0)\nT, h_v0 = signal.impulse(H_v0)\nT, h_p0 = signal.impulse(H_p0)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t0)\nax[1].plot(T, h_v0)\nax[2].plot(T, h_p0)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\theta$')\nax[0].set_ylabel(r'$h_{T0}$')\nax[1].set_ylabel(r'$h_{V0}$')\nax[2].set_ylabel(r'$h_{P0}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 4: Respuestas al impulso de las fuentes de ruido sobre la posición angular.\n\n\n\n\n\n\n\nCódigo\nT, h_t1 = signal.impulse(H_t1)\nT, h_v1 = signal.impulse(H_v1)\nT, h_p1 = signal.impulse(H_p1)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].plot(T, h_t1)\nax[1].plot(T, h_v1)\nax[2].plot(T, h_p1)\n\nfig.suptitle(r'Respuestas al impulso del sistema sobre $\\dot\\theta$')\nax[0].set_ylabel(r'$h_{V1}$')\nax[1].set_ylabel(r'$h_{V1}$')\nax[2].set_ylabel(r'$h_{V1}$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(min(T), max(T))\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 5: Respuestas al impulso de las fuentes de ruido sobre la velocidad angular.\n\n\n\n\n\nLos resultados presentados en las figuras indican un estado transitorio de aproximadamente \\(50\\) s, lo cual da una noción de la escala temporal del sistema. Este resultado motiva la elección de un tiempo de muestreo de \\(T_s = 10\\) ms para realizar una simulación digital del sistema."
  },
  {
    "objectID": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "href": "TP1_Propagación_Ruido_LTI.html#análisis-de-la-respuesta-del-sistema-ante-ruido-blanco",
    "title": "TP1 - Propagación de Ruido en Sistemas LTI",
    "section": "Análisis de la respuesta del sistema ante ruido blanco",
    "text": "Análisis de la respuesta del sistema ante ruido blanco\nA partir de los gráficos de las respuestas al impulso presentados en la Figura 4 y Figura 5, así como las expresiones de las transferencias presentadas en la Ecuación 13, se determina que la respuesta del sistema ante las fuentes de ruido solo varía por un factor multiplicativo. Por este motivo se procede únicamente a analizar la respuesta al ruido de torque, sabiendo que el comportamiento ante el ruido de posición y el ruido de velocidad será similar.\n\nSimulación temporal\nPara simular la respuesta del sistema ante ruido blanco, se define una señal de entrada \\(n_T[t]\\) de \\(N\\) muestras independientes idénticamente distribuidas, definida por\n\\[\n  \\mathbf{n_T} \\sim \\mathcal{N}(\\mathbf 0_N, \\sigma^2 I_N)\n\\]\nA partir de esta señal se simulan las salidas, \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\), utilizando scipy.signal.lsim.\n\n\nCódigo\nimport numpy as np\n\nt_s = 1e-2\nvar_n = 100\nN = 400000\nt = np.linspace(0, N*t_s, N)\n\nn_t = np.random.normal(0, np.sqrt(var_n), N)\n\nT, pos, _ = signal.lsim(H_t0, n_t, t)\nT, vel, _ = signal.lsim(H_t1, n_t, t)\n\nfig, ax = plt.subplots(3,1, sharex=True)\nfig.suptitle('Respuestas del sistema ante una entrada de ruido blanco', fontsize=16)\nax[0].plot(T, n_t)\nax[1].plot(T, pos)\nax[2].plot(T, vel)\nax[0].set_ylabel(r'$n_T$')\nax[1].set_ylabel(r'$\\theta$')\nax[2].set_ylabel(r'$\\dot\\theta$')\nax[2].set_xlabel(r'$t$ [s]')\nfor i in [0,1,2]:\n  ax[i].set_xlim(0,800)\n  ax[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigura 6: Respuestas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nSe calcula el valor cuadrático medio empírico de las señales con la fórumla\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\frac{1}{N}\\sum_{t=0}^{N-1}x^2[t]\n\\]\nLos resultados para la realización vista en la Figura 6 se presentan a continuación\n\n\nCódigo\ndef round_sig_figs(value, sig_figs):\n    if value == 0:\n        return 0\n    else:\n        return round(value, sig_figs - int(np.floor(np.log10(abs(value)))) - 1)\n\nmsv_ruido = np.mean([n**2 for n in n_t])\nmsv_pos = np.mean([n**2 for n in pos])\nmsv_vel = np.mean([n**2 for n in vel])\n\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     99.9\nValor cuadrático medio de la posición angular:   0.0417\nValor cuadrático medio de la velocidad angular:  0.000401\n\n\n\n\nAnálisis en el dominio de la frecuencia\nSe procede a calcular la distribución espectral de potencia de \\(\\theta[t]\\) y \\(\\dot\\theta[t]\\) ante la entrada \\(n_T[t]\\), a partir de la expresión teórica\n\\[\n\\begin{aligned}\nS_\\theta(f) &= \\left| H_{T0}(j2\\pi f) \\right|^2 S_{N_T}(f)\\\\\nS_{\\dot\\theta}(f) &= \\left| H_{T1}(j2\\pi f) \\right|^2 S_{N_T}(f)\n\\end{aligned}\n\\]\nEn donde \\(S_{n_T}\\) es la distribución espectral de potencia de ruido blanco con varianza \\(\\sigma^2\\) muestreado a una frecuencia \\(f_s = 1/T_S\\)\n\\[\n  S_{N_T}(f) = \\frac{\\sigma^2}{f_S} \\Pi\\left(\\frac{f}{f_S}\\right)\n\\]\n\n\nCódigo\nf = np.fft.fftfreq(N, t_s)\npsd_N = np.array([var_n*t_s for x in f])\n\ndef H_T0fun(f):\n    w = 2*np.pi*f\n    return -C_p/(J*(1j*w)**2+C_d*1j*w+C_p)\n\ndef H_T1fun(f):\n    w = 2*np.pi*f\n    return -C_p*(1j*w)/(J*(1j*w)**2+C_d*1j*w+C_p)\n\nS_0 = np.array([np.abs(H_T0fun(fi))**2 for fi in f])*psd_N\nS_1 = np.array([np.abs(H_T1fun(fi))**2 for fi in f])*psd_N\n\nfig, ax = plt.subplots(3,1, sharex=True)\nax[0].loglog(f[0:N//2], psd_N[0:N//2])\nax[1].loglog(f[0:N//2], S_0[0:N//2])\nax[2].loglog(f[0:N//2], S_1[0:N//2])\nfig.suptitle('Distribución Espectral de Potencia')\nax[0].set_ylabel(r'$S_{N_T}$')\nax[1].set_ylabel(r'$S_{\\Theta}$')\nax[2].set_ylabel(r'$S_{\\dot\\Theta}$')\nax[2].set_xlabel(r'$f$ [Hz]')\nfor i in [0,1,2]:\n    ax[i].grid(True)\n\n\n\n\n\n\n\n\nFigura 7: Distribución espectral de potencia de las salidas del sistema ante una entrada de ruido blanco\n\n\n\n\n\nLa Figura 7 indica que \\(H_{T0}\\) actúa como un filtro pasa bajo, mientras que \\(H_{T1}\\) actúa como un filtro pasa banda. Esto es consistente con un análisis cualitativo de las formas de onda presentadas en la Figura 6, así como de las tranferencias presentadas en la Ecuación 13.\nFinalmente, se calcula el valor cuadrático medio teórico de las señales, dado por\n\\[\n  \\text{MSV}(\\mathbf{x}) = \\int_{-\\infty}^{\\infty} S_X(f) df\n\\]\nLos resultados utilizando integración numérica se presentan a continuación.\n\n\nCódigo\nf = np.fft.fftshift(f)\nS_0 = np.fft.fftshift(S_0)\nS_1 = np.fft.fftshift(S_1)\n\nmsv_ruido = np.trapezoid(psd_N, f)\nmsv_pos = np.trapezoid(S_0, f)\nmsv_vel = np.trapezoid(S_1, f)\n\nprint(f\"Valor cuadrático medio del ruido de entrada:\\t {round_sig_figs(msv_ruido, 3)}\")\nprint(f\"Valor cuadrático medio de la posición angular:\\t {round_sig_figs(msv_pos, 3)}\")\nprint(f\"Valor cuadrático medio de la velocidad angular:\\t {round_sig_figs(msv_vel, 3)}\")\n\n\nValor cuadrático medio del ruido de entrada:     100.0\nValor cuadrático medio de la posición angular:   0.0357\nValor cuadrático medio de la velocidad angular:  0.000357"
  },
  {
    "objectID": "kalman2.html",
    "href": "kalman2.html",
    "title": "",
    "section": "",
    "text": "using LinearAlgebra\nusing Distributions\nusing Plots\nusing ColorSchemes\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\n\nprintln(Q)\nprintln(R)\n\n[6.4000000000000006e-6 0.0 0.0; 0.0 6.4000000000000006e-6 0.0; 0.0 0.0 2.7415567780803773e-6]\n[6.25 0.0 0.0; 0.0 6.25 0.0; 0.0 0.0 1.5551418366801118e-7]\n\n\n\ndiagm([10,10,10])\n\n3×3 Matrix{Int64}:\n 10   0   0\n  0  10   0\n  0   0  10\n\n\n\n# Generadores de datos \n\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\n## Matrices filtro Kalman\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\n3×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  1\n\n\n\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\nfunction kalman_initialize(t, tasa_GPS, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N÷tasa_GPS)\n    return x, P, K\nend\n\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, tasa_GPS, z)\n    for k in 2:length(t)\n        x_est, P_est = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est, K_k = kalman_correct(x_est, z[:,k], P_est)\n            K[:,:,k÷tasa_GPS] = K_k\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n    end\n    return x, P\nend\n\nkalman (generic function with 1 method)\n\n\n\nT = 500\nt = 0:0.1:T\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\nu = u_true + u_noise\nz = z_true + z_noise\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.22380275271364 … -0.17930100163669135 -0.1795083568166394; 0.0 -0.0003103366528196452 … -0.0018967979237825012 -0.002250305675178356; … ; 0.0 -0.00041613986353679247 … -0.0077613489996968725 -0.007801436660320887; -0.0002794640187689196 -0.00030817631756576455 … 2.2592111624671762e-5 -2.8431199440788638e-5], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.013290796118887e-28 0.0; 0.6250000032 6.250000064 … 2.4943584589793974e-28 0.0; … ; -7.088765594317273e-31 -4.395064373185345e-28 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … 7.38064560983693e-29 0.0; 1.2500000128000002 6.250000128 … 9.772577152374617e-28 0.0; … ; -6.938253732913538e-29 9.258807670461116e-28 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … 3.8033289446895193e-25 0.0; 0.002020370544845382 5.0854141278523966e-5 … -1.920307048984724e-26 0.0; … ; -3.9438733496621813e-26 2.854035111629257e-26 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … 3.6088972364073983e-25 0.0; 0.001974861075922868 5.027814120589553e-5 … -1.788868929978571e-26 0.0; … ; -3.379204849591105e-26 2.942533968508753e-26 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … 3.5909621971294503e-25 0.0; 0.001979892090043457 5.034214120589553e-5 … -1.78501228015534e-26 0.0; … ; -3.0856407044011273e-26 2.9440959920039314e-26 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t (generic function with 1 method)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\nfunction estimation_error(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\nfunction plot_error(t, x, z_true, P)\n    p1 = plot(t, varianza_estimador(P))\n    p2 = plot(t, estimation_error(x, z_true))\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction mru_IMU()\n    return [0,0,0]\nend\nfunction mru_GPS(v, t, θ)\n    return [v*t*cos(θ),v*t*sin(θ),θ]\nend\n\nmru_GPS (generic function with 1 method)\n\n\n\nt_gps = t[1:10:end]\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([mru_GPS(100/T, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P = kalman(t, 10, u, z)\n\n([-1.223787235880999 -1.2237834951726105 … 70.58344470989839 70.59774251957364; 0.0 7.481416776940403e-5 … 0.143088907488292 0.14286728601674714; … ; 0.0 -0.0005136964710884169 … 0.13551697562445592 0.13523866163957277; 0.7851186993786794 0.7850899870798825 … 0.785420755509073 0.7853697321980075], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 1.1092301608009414e-25 0.0; 0.6250000032 6.250000064 … 3.9049200030955144e-25 0.0; … ; 1.9507123971656156e-25 1.1683928264965458e-24 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … -3.719139900271429e-26 0.0; 1.2500000128000002 6.250000128 … 8.275884030191062e-25 0.0; … ; 8.750696298758388e-26 4.391923111483954e-25 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … -1.8807255502262903e-21 0.0; 0.002020370544845382 5.0854141278523966e-5 … -6.360334456139304e-23 0.0; … ; 1.675403548287672e-21 2.937425523829086e-23 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … -1.8180632741629165e-21 0.0; 0.001974861075922868 5.027814120589553e-5 … -6.027221892540865e-23 0.0; … ; 1.61435427376303e-21 3.103030558032755e-23 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … -1.824114592005475e-21 0.0; 0.001979892090043457 5.034214120589553e-5 … -6.010226026335021e-23 0.0; … ; 1.6173663075581039e-21 3.152330368175671e-23 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7])\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\n3×5001 Matrix{Float64}:\n 18.7762    19.9011   24.5303    22.248    …  19.5701   19.6944   20.2105\n  0.739645  -3.65581  -0.937314   2.46585      2.6014   -3.40718  -2.94765\n  1.57052    1.57188   1.57352    1.57431      7.85118   7.85282   7.85396\n\n\n\nx, P = kalman(t, 10, u, z)\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)"
  },
  {
    "objectID": "kalman.html",
    "href": "kalman.html",
    "title": "",
    "section": "",
    "text": "using LinearAlgebra\nusing Distributions\nusing Plots\nusing ColorSchemes\n\n## Parametros de error instrumentos\n\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\n\nprintln(Q)\nprintln(R)\n\n[6.4000000000000006e-6 0.0 0.0; 0.0 6.4000000000000006e-6 0.0; 0.0 0.0 2.7415567780803773e-6]\n[6.25 0.0 0.0; 0.0 6.25 0.0; 0.0 0.0 1.5551418366801118e-7]\n\n\n\n# Generadores de datos \n\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nestatico_GPS (generic function with 1 method)\n\n\n\n## Matrices filtro Kalman\n\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]\n\n3×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  1\n\n\n\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    K = P_est*H'*inv(H*P_est*H'+R)\n    return x_est, P_est, K\nend\n\nfunction kalman_correct(x_prior, z, P_prior, K)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est\nend\n\nfunction kalman_initialize(t, z)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([err_GPS^2,(err_GPS*fs2)^2,err_GPS^2,(err_GPS*fs2)^2,2pi])\n    K = zeros(5, 3, N)\n    return x, P, K\nend\n\nfunction kalman(t, tasa_GPS, u, z)\n    x, P, K = kalman_initialize(t, z)\n    for k in 2:length(t)\n        x_est, P_est, K_k = kalman_predict(x[:,k-1], u[:,k], P[:,:,k-1])\n        if k%tasa_GPS == 0\n            x_est, P_est = kalman_correct(x_est, z[:,k], P_est, K_k)\n        end\n        x[:,k] = x_est\n        P[:,:,k] = P_est\n        K[:,:,k] = K_k\n    end\n    return x, P, K\nend\n\nkalman (generic function with 1 method)\n\n\n\nT = 500\nt = 0:0.1:T\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\nu = u_true + u_noise\nz = z_true + z_noise\nx, P, K = kalman(t, 10, u, z)\n\n([-1.455122915634084 -1.4551266946649777 … 0.43661832450277066 0.4373575556776893; 0.0 -7.558061787461232e-5 … 0.007282315604079254 0.007502307894293981; … ; 0.0 -0.00016725030909564152 … 0.0007199402423739461 0.0009028827275953279; 0.00014334875152236039 0.00027569479676976794 … -0.0006970379408270451 -0.001048817905282591], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … -6.003137944404287e-29 0.0; 0.6250000032 6.250000064 … -1.1198482454656182e-27 0.0; … ; -3.2322725620722296e-29 1.1126949727411405e-27 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … -1.8461988969980026e-28 0.0; 1.2500000128000002 6.250000128 … 1.3745759714928516e-27 0.0; … ; -4.212872148581202e-29 -1.6912795474562842e-27 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … -9.236402287804786e-25 0.0; 0.002020370544845382 5.0854141278523966e-5 … -1.1086519104518691e-26 0.0; … ; 1.1947562262711023e-24 4.0292711162424657e-26 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … -8.855154416115763e-25 0.0; 0.001974861075922868 5.027814120589553e-5 … -1.1137278968327343e-26 0.0; … ; 1.1547390134039272e-24 3.898124076277279e-26 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … -8.863860169827566e-25 0.0; 0.001979892090043457 5.034214120589553e-5 … -7.8898124493625e-27 0.0; … ; 1.1587782797114153e-24 3.3640423879478805e-26 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.5024875621953911 -6.947897029218226e-33 0.0; 0.04975124403518725 -2.1674812533763615e-30 0.0; … ; -2.5690210040559647e-30 0.04975124403518725 0.0; 0.0 0.0 0.9999999752491497;;; 0.5098039216301423 -7.133371303051824e-31 0.0; 0.09803921667789314 -5.895129791931655e-30 0.0; … ; -3.4133014905362986e-30 0.09803921667789314 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.024919500025468617 -7.968357873216536e-24 0.0; 0.0003152038273602642 -1.4121078868998485e-25 0.0; … ; 1.841501146595868e-25 0.0003152038273602642 0.0; 0.0 0.0 0.6968640780830011;;; 0.024981043348223344 -7.995436031636309e-24 0.0; 0.00031597777214765885 -1.4134422045666749e-25 0.0; … ; 1.8475824214462833e-25 0.00031597777214765885 0.0; 0.0 0.0 0.7122418117142865;;; 0.024432425896073577 -7.636465622617649e-24 0.0; 0.00030904296372339973 -1.3564810111447277e-25 0.0; … ; 1.7875681563194114e-25 0.00030904296372339973 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\nprintln(length(t))\n\n5001\n\n\n\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t (generic function with 1 method)\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\nfunction estimation_error(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\nfunction kalman_gain(K)\n    return [norm(K[:,:,i]) for i in 1:size(K,3)]\nend\n\nfunction plot_error(t, x, z_true, P)\n    v = varianza_estimador(P)\n    e = estimation_error(x, z_true)\n    p1 = plot(t, v, ylim=[0, maximum(v)*1.1], ylabel=\"tr[P]\")\n    p2 = plot(t, e, ylim=[0, maximum(e)*1.1], ylabel=\"Error cuadrático\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction plot_gain(t, P, K)\n    v = varianza_estimador(P)\n    k = kalman_gain(K)\n    p1 = plot(t, v, ylim=[0, maximum(v)*1.1], ylabel=\"tr[P]\")\n    p2 = plot(t, k, ylim=[0, maximum(k)*1.1], ylabel=\"norm[K]\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_gain (generic function with 1 method)\n\n\n\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction mru_IMU()\n    return [0,0,0]\nend\nfunction mru_GPS(v, t, θ)\n    return [v*t*cos(θ),v*t*sin(θ),θ]\nend\n\nmru_GPS (generic function with 1 method)\n\n\n\nt_gps = t[1:10:end]\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([mru_GPS(100/T, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n([-1.455122915634084 -1.4551196746210693 … 71.04583210487 71.06043381484648; 0.0 6.482026029166666e-5 … 0.14600400068060956 0.14603019884896198; … ; 0.0 -0.00017170739514248183 … 0.1443657894650829 0.14465070737716967; 0.7855415121489706 0.785673858194218 … 0.7847011254566213 0.7843493454921657], [6.25 0.0 … 0.0 0.0; 0.0 6.25 … 0.0 0.0; … ; 0.0 0.0 … 6.25 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 6.31250000016 0.6250000032 … 2.020363492347095e-25 0.0; 0.6250000032 6.250000064 … 1.0576043079681538e-24 0.0; … ; -1.2500722377230287e-25 -2.2983727115458583e-25 … 6.250000064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 6.5000000016 1.2500000128000002 … 1.0351342895623755e-25 0.0; 1.2500000128000002 6.250000128 … 3.6294765830931514e-24 0.0; … ; -3.2007887038344932e-25 9.950320908232273e-25 … 6.250000128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 0.15972719705013783 0.002020370544845382 … 1.2349267219469864e-22 0.0; 0.002020370544845382 5.0854141278523966e-5 … -6.461366311617965e-23 0.0; … ; 1.1007647020105417e-21 4.9882935681744137e-23 … 5.0854141278523966e-5 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 0.1561315209263959 0.001974861075922868 … 1.071220543163716e-22 0.0; 0.001974861075922868 5.027814120589553e-5 … -6.457550655844659e-23 0.0; … ; 1.065624571130108e-21 4.8418474385616516e-23 … 5.027814120589553e-5 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 0.15652699608299256 0.001979892090043457 … 1.0066843910166404e-22 0.0; 0.001979892090043457 5.034214120589553e-5 … -6.527660284659505e-23 0.0; … ; 1.0705534551643103e-21 4.660095964645261e-23 … 5.034214120589553e-5 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.5024875621953911 -6.635732336561041e-29 0.0; 0.04975124403518725 8.511774262827701e-27 0.0; … ; -9.929951327842314e-27 0.04975124403518725 0.0; 0.0 0.0 0.9999999752491497;;; 0.5098039216301423 1.284238058863339e-27 0.0; 0.09803921667789314 3.980807534862416e-26 0.0; … ; -2.483620215522077e-26 0.09803921667789314 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.024919500025468617 3.3555849937073426e-21 0.0; 0.0003152038273602642 1.8338111435848127e-23 0.0; … ; 1.6978442475386313e-22 0.0003152038273602642 0.0; 0.0 0.0 0.6968640780830011;;; 0.024981043348223344 3.3588352233304512e-21 0.0; 0.00031597777214765885 1.7346316334584408e-23 0.0; … ; 1.7049993138081728e-22 0.00031597777214765885 0.0; 0.0 0.0 0.7122418117142865;;; 0.024432425896073577 3.1998951648715362e-21 0.0; 0.00030904296372339973 1.4904849917001566e-23 0.0; … ; 1.6526556414272418e-22 0.00030904296372339973 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nk1 = 4000\nk2 = 4200\nplot_error(t[k1:k2], x[:,k1:k2], z_true[:,k1:k2], P[:,:,k1:k2])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Generadores de datos \n\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\n3×5001 Matrix{Float64}:\n 18.5449   23.6599    17.9874    17.2268   …  20.562    20.6889   12.9903\n  0.75353  -0.921717   0.657405  -4.96342      3.65828   2.87319   4.08529\n  1.57094   1.57181    1.57291    1.57442      7.85208   7.85188   7.8543\n\n\n\nx, P, K = kalman(t, 10, u, z)\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrayectoria_t(t, x, z_true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_error(t, x, z_true, P)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nk1 = 4000\nk2 = 4200\nplot_error(t[k1:k2], x[:,k1:k2], z_true[:,k1:k2], P[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html",
    "href": "TP2_Filtro_Kalman.html",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\).\n\n\n\nCódigo\nusing LinearAlgebra\nusing Distributions\nusing Plots\nusing PlotThemes\n\ntheme(:wong2)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "href": "TP2_Filtro_Kalman.html#descripción-del-problema",
    "title": "TP2 - Filtros de Kalman",
    "section": "",
    "text": "Se implementará un filtro de Kalman para fusionar los datos de sensores presentes en un vehículo para estimar la posición y orientación del mismo en dos dimensiones. Un diagrama del mismo se presenta en la Figura 1.\n\n\n\n\n\n\nFigura 1: Esquema del sistema.\n\n\n\nEn la figura se representan los ejes \\(x\\) e \\(y\\), llamados el sistema de referencia inercial. Se repesenta además el eje \\(x_b\\), el cual junto con un eje \\(y_b\\) ortogonal al mismo forman el sistema de referencia del móvil, llamado body. El filtro de Kalman estimará la posición del móvil en el sistema de referencia intercial, \\(x_{est},\\, y_{est}\\) así como la orientación del mismo, dada por el ángulo \\(\\theta\\).\nLos instrumentos disponibles para la estimación de la posición son los siguientes.\n\nUnidad de Medición Inercial (IMU): Consiste en un giróscopo y un acelerómetro los cuales miden a una tasa \\(f_s\\).\n\nAcelerómetro: Mide la aceleración lineal del móvil en el sistema body, \\(u^{x_b} = \\ddot{x}_b\\) y \\(u^{y_b} = \\ddot{y}_b\\).\nGiróscopo: Mide la velocidad angular del móvil, \\(u^{\\theta} = \\dot{\\theta}\\).\n\nGPS: Mide la posición del móvil en el sistema de referencia inercial a una tasa \\(f_s'\\).\nMagnetómetro: Por medio de mediciones del campo magnético terrestre calcula la orientación del móvil, también a tasa \\(f_s'\\).\n\n\n\nCódigo\nusing LinearAlgebra\nusing Distributions\nusing Plots\nusing PlotThemes\n\ntheme(:wong2)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "href": "TP2_Filtro_Kalman.html#error-de-los-instrumentos",
    "title": "TP2 - Filtros de Kalman",
    "section": "Error de los instrumentos",
    "text": "Error de los instrumentos\nPara cada dimensión de medición se considera su correspondiente error. Se hace a partir de los datos en la hoja de datos.\n\n\n\n\n\n\n\n\nParámetro\nSímbolo\nValor\n\n\n\n\nFrecuencia de muestreo IMU\n\\(f_s\\)\n\\(10 \\, \\mathrm{Hz}\\)\n\n\nFrecuencia de muestreo GPS\n\\(f_s'\\)\n\\(1 \\, \\mathrm{Hz}\\)\n\n\nPSD ruido acelerómetro\n\\(S_{acc}\\)\n\\(80\\, \\mathrm{\\mu g}/\\sqrt{\\mathrm{Hz}}\\)\n\n\nPSD ruido giróscopo\n\\(S_{gir}\\)\n\\(0.03\\, ^\\circ/s/\\sqrt{\\mathrm{Hz}}\\)\n\n\nPSD ruido giróscopo\n\\(S_{gir}\\)\n\\(100\\, \\mathrm{\\mu Gauss}/\\sqrt{\\mathrm{Hz}}\\)\n\n\nError absoluto del GPS\n\\(\\sigma_{GPS}\\)\n\\(2.5\\, \\mathrm{m}\\)\n\n\nIntensidad campo magnético\n\\(B_T\\)\n\\(25358\\,\\mathrm{nT}\\)\n\n\n\nEl error de las mediciones del IMU se calculan a partir de la densidad espectral del ruido informada en la hoja de datos, \\(S_{acc}\\) para el acelerómetro y \\(S_{gir}\\) para el giróscopo, y la frecuencia de muestreo \\(f_s\\)\n\\[\n\\sigma_{acc} = S_{acc} \\sqrt{fs}  \\qquad\n\\sigma_{acc} = S_{gir} \\sqrt{fs}\n\\]\nEl error del magnetómetro se calcula también a partir de su densidad espectral de ruido \\(S_{mag}\\) y su frecuencia de muestreo \\(f_s'\\), y también es afectado por la intensidad del campo magnético terrestre \\(B_T\\)\n\\[\n\\sigma_{mag} = \\frac{S_{mag} \\sqrt{fs'}}{B_T}\n\\]\nFialmente, el error del GPS no depende de la frecuencia de muestreo, y es informado diréctamente en la hoja de datos\n\n\nCódigo\nΔt = 0.1\n\nfs = 10\nfs2 = 1\nPSD_a = 80*10*1e-6\nPSD_g = 0.03*π/180\nPSD_m = 100e-6*1e-4\nB_T = 25358e-9\n\nerr_IMU_x = PSD_a*sqrt(fs)\nerr_IMU_θ = PSD_g*sqrt(fs)\n\nerr_GPS = 2.5\nerr_MAG = PSD_m*sqrt(fs2)/B_T\n\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\n\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-de-estado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización de estado",
    "text": "Modelo de actualización de estado\nEn ausencia de aceleración, la evolución del estado en un tiempo \\(\\Delta t\\) seguiría un movimiento rectilíneo uniforme, dado por\n\\[\n\\mathbf{x}_k = \\begin{bmatrix}x_k \\\\ \\dot{x}_k \\\\ y_k \\\\ \\dot{y}_k \\\\ \\theta_k \\end{bmatrix} =\n\\begin{bmatrix}\n1 & \\Delta t & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & \\Delta t & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}x_{k-1} \\\\ \\dot{x}_{k-1} \\\\ y_{k-1} \\\\ \\dot{y}_{k-1} \\\\ \\theta_{k-1} \\end{bmatrix}\n\\]\nLa actualización del estado se hace en función de las mediciones de la IMU, que informan la aceleración del móvil en el sistema de referencia body, estas se modelan como el vector de medición \\(\\mathbf u\\) más el vector de error \\(\\mathbf w'\\)\nEstas aceleraciones se transladan al sistema de referencia inercial y se utilizan para realizar la actualización por modelo del filtro de Kalman, dada por medio de la ecuación\n\\[\n  \\mathbf{\\hat{x}}_k = A\\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{u}_{k-1} + \\mathbf{w}_{k-1}\n\\]\nEn donde la matriz \\(B_{k-1}\\) que obtiene la actualización del estado en el sistema inercial \\(\\mathbf{x}\\) en función de las mediciones de aceleración en el sistema body es dada por\n\\[\n  B_{k-1} = \\begin{bmatrix} \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                    - \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                    - \\Delta t \\sin(\\theta_{k-1}) &\n                      0 \\\\\n                      \\frac 1 2 \\Delta t^2 \\sin(\\theta_{k-1}) &\n                      \\frac 1 2 \\Delta t^2 \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      \\Delta t \\sin(\\theta_{k-1}) &\n                      \\Delta t \\cos(\\theta_{k-1}) &\n                      0 \\\\\n                      0 & 0 & \\Delta t\n  \\end{bmatrix}\n\\]\nY el ruido es similarmente transformado, obteniendo \\(\\mathbf{w}_{k-1} = B \\mathbf{w}_{k-1}'\\). La matriz de covarianza que resulta de la transformación es dada por\n\\[\n  Q_k = B Q B^T\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "href": "TP2_Filtro_Kalman.html#modelo-de-actualización-por-medición",
    "title": "TP2 - Filtros de Kalman",
    "section": "Modelo de actualización por medición",
    "text": "Modelo de actualización por medición\nLa actualización por medición se basa en relacionar las mediciones del GPS y el magnetómetro con el estado actual \\(\\mathbf{\\hat{x}}\\) de la siguiente forma\n\\[\nH\\mathbf{\\hat{x}}_k = \\mathbf{z}_k + \\mathbf{v}_k\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1\n\\]\nY el vector de ruido tiene matriz de covarianza \\(R\\)\n\n\nCódigo\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "href": "TP2_Filtro_Kalman.html#algoritmo-de-estimación",
    "title": "TP2 - Filtros de Kalman",
    "section": "Algoritmo de estimación",
    "text": "Algoritmo de estimación\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    return x_est, P_est\nend\n\n\nkalman_predict (generic function with 1 method)\n\n\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior)\n    K = P_prior*H'*inv(H*P_prior*H'+R)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est, K\nend\n\n\nkalman_correct (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-imu",
    "href": "TP2_Filtro_Kalman.html#medición-del-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del IMU",
    "text": "Medición del IMU\nA cada instante de muestreo del IMU se obtiene un vector de mediciones \\(\\mathbf{\\overline{u}}_k\\), el cual se define como su valor real \\(\\mathbf{u}_k\\) más su error \\(\\mathbf{w'}_k\\)\n\\[\n  \\mathbf{\\overline{u}}_k =\n  \\mathbf{u}_k + \\mathbf{w}_k' = \\begin{bmatrix}u_k^{x_b} \\\\ u_k^{y_b} \\\\\n  u_k^{\\theta} \\end{bmatrix} + \\mathbf{w}_k'\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{w}'\\) es dada por\n\\[\n  Q = \\begin{bmatrix}\n    (\\sigma_{acc})^2 & 0 & 0\\\\\n    0 & (\\sigma_{acc})^2 & 0\\\\\n    0 & 0 & (\\sigma_{gir})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "href": "TP2_Filtro_Kalman.html#medición-del-gpsmagnetómetro",
    "title": "TP2 - Filtros de Kalman",
    "section": "Medición del GPS/Magnetómetro",
    "text": "Medición del GPS/Magnetómetro\nCuando \\(k\\) corresponde a un instante de muestreo del GPS, se obtiene un vector de mediciones \\(\\mathbf{\\overline{z}}_k\\), el cual se define como su valor real \\(\\mathbf{z}_k\\) más su error \\(\\mathbf{v}_k\\)\n\\[\n  \\mathbf{\\overline{z}}_k =\n  \\mathbf{z}_k + \\mathbf{v}_k = \\begin{bmatrix}z_k^{x} \\\\ z_k^{y} \\\\\n  z_k^{\\theta} \\end{bmatrix} + \\mathbf{v}_k\n\\]\nLos errores de medición se consideran independientes, por lo que la matriz de covarianza de \\(\\mathbf{w}'\\) es dada por\n\\[\n  R = \\begin{bmatrix}\n    (\\sigma_{GPS})^2 & 0 & 0\\\\\n    0 & (\\sigma_{GPS})^2 & 0\\\\\n    0 & 0 & (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#inicialización",
    "href": "TP2_Filtro_Kalman.html#inicialización",
    "title": "TP2 - Filtros de Kalman",
    "section": "Inicialización",
    "text": "Inicialización\nLos valores de posición y orientación del estado \\(\\mathbf{\\hat{x}}\\) se inicializan con las primeras mediciones provenientes del GPS/magnetómetro. Los valores de velocidad se inicializan en \\(0\\).\nSe decide inicializar la matriz de covarianza con el error del GPS para la posición, el error del GPS multiplicado por la frecuencia de muestreo para la velocidad, y \\(2\\pi\\) para la orientación.\n\n\nCódigo\nfunction kalman_initialize(t, z, R)\n    N = length(t)\n    x = zeros(5, N)\n    x[1:2:5,1] = z[:,1]\n    P = zeros(5, 5, N)\n    P[:,:,1] = diagm([R[1,1]^2,(R[1,1]*fs2)^2,R[2,2]^2,(R[2,2]*fs2)^2,2pi])\n    K = zeros(5, 3, N)\n    return x, P, K\nend\n\n\nkalman_initialize (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#predicción",
    "href": "TP2_Filtro_Kalman.html#predicción",
    "title": "TP2 - Filtros de Kalman",
    "section": "Predicción",
    "text": "Predicción\nEn cada instante de muestreo del IMU se realiza la etapa de predicción\n\nEstimación a priori: \\(\\mathbf{\\hat{x}}_k^{-} = \\mathbf{\\hat{x}}_{k-1} + B_{k-1} \\mathbf{\\overline{u}}_{k-1}\\)\nCovarianza a priori: \\(P_k^{-} = A P_{k-1}A^T + Q_k\\)\nGanancia de Kalman: \\(K_k = P^{-}_k H^T (H P_k^{-}H^T + R_k)^{-1}\\)\n\n\n\nCódigo\nfunction kalman_predict(x, u, P, Q, R)\n    B = B_matrix(x[5])\n    x_est = A*x + B*u\n    P_est = A*P*A' + B*Q*B'\n    K = P_est*H'*inv(H*P_est*H'+R)\n    return x_est, P_est, K\nend\n\n\nkalman_predict (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#corrección",
    "href": "TP2_Filtro_Kalman.html#corrección",
    "title": "TP2 - Filtros de Kalman",
    "section": "Corrección",
    "text": "Corrección\nEn cada instante de muestreo del GPS/magnetómetro, se aplica una corrección por medición al estimador.\n\nEstimador a posteriori: \\(\\mathbf{\\hat{x}}_k^{+} = \\mathbf{\\hat{x}}_k^{-} + K_k (\\mathbf{\\overline{z}}_k-H\\mathbf{\\hat{x}}_k^{-})\\)\nCovarianza a posteriori: \\(P_k^{+} = (I-K_k H)P_k^{-}\\)\n\n\n\nCódigo\nfunction kalman_correct(x_prior, z, P_prior, K)\n    x_est = x_prior + K*(z-H*x_prior)\n    P_est = (I-K*H)*P_prior\n    return x_est, P_est\nend\n\n\nkalman_correct (generic function with 1 method)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#móvil-estático",
    "href": "TP2_Filtro_Kalman.html#móvil-estático",
    "title": "TP2 - Filtros de Kalman",
    "section": "Móvil estático",
    "text": "Móvil estático\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo se encuentra en reposo.\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por\n\\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} 0 \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction estatico_IMU()\n    return [0,0,0]\nend\nfunction estatico_GPS()\n    return [0,0,0]\nend\n\nu_true = hcat([estatico_IMU() for ti in t]...)\nz_true = hcat([estatico_GPS() for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\nfunction trayectoria_xy(x, z_true)\n    p1 = plot(x[1,:], x[3,:], label=\"Estimación\", xlabel=\"x\", ylabel=\"y\", aspect_ratio=:equal, title=\"Trayectoria XY\")\n    plot!(p1, z_true[1,:], z_true[2,:], label=\"Trayectoria\")\n    return p1\nend\n\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nfunction trayectoria_t(t, x, z_true)\n    p1 = plot(t, x[1,:], ylabel=\"x [m]\", title=\"Trayectoria en función del tiempo\")\n    plot!(p1, t, z_true[1,:])\n    p2 = plot(t, x[3,:], ylabel=\"y [m]\")\n    plot!(p2, t, z_true[2,:])\n    p3 = plot(t, x[5,:] .% 2pi, ylabel=\"θ\", xlabel=\"t [s]\")\n    plot!(p3, t, z_true[3,:] .% 2pi)\n    return plot(p1,p2,p3, layout=(3,1), legend=false)\nend\n\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "href": "TP2_Filtro_Kalman.html#movimiento-rectilíneo-uniformemente-acelerado",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento rectilíneo uniformemente acelerado",
    "text": "Movimiento rectilíneo uniformemente acelerado\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo parte del reposo y sigue un movimiento rectilíneo uniformemente acelerado con aceleración \\(a\\) a un ángulo \\(\\theta\\) respecto a la horizontal.\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por \\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} a \\\\ 0 \\\\\n  0 \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} \\frac 1 2 a t_k^2 \\cos(\\theta)  \\\\ \\frac 1 2 a t_k^2 \\sin(\\theta)  \\\\\n  \\theta \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction mrua_IMU(a)\n    return [a,0,0]\nend\nfunction mrua_GPS(a, t, θ)\n    return [1/2 * a * t^2 * cos(θ), 1/2 * a* t^2 * sin(θ), θ]\nend\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "href": "TP2_Filtro_Kalman.html#movimiento-circular-uniforme",
    "title": "TP2 - Filtros de Kalman",
    "section": "Movimiento circular uniforme",
    "text": "Movimiento circular uniforme\nSe analiza la trayectoria real, dada por \\(\\mathbf{z}\\), contra la trayectoria estimada extraida de \\(\\mathbf{\\hat{x}}\\) en el caso de que el vehículo sigue un movimiento circular uniforme a un radio \\(r\\) del origen y con velocidad angular \\(\\omega\\).\nEn este caso los vectores de medición \\(\\mathbf{\\overline{u}}\\) y \\(\\mathbf{\\overline{z}}\\) son dados por \\[\n    \\mathbf{\\overline{u}}_k = \\begin{bmatrix} 0 \\\\ \\omega^2 r \\\\\n  \\omega \\end{bmatrix} + \\mathbf{w}_k'\n\\qquad\\qquad\n    \\mathbf{\\overline{z}}_k = \\begin{bmatrix} r \\cos(\\omega t_k)  \\\\ r \\sin(\\omega t_k)  \\\\\n  \\omega t_k + \\frac \\pi 2 \\end{bmatrix} + \\mathbf{v}_k\n\\]\n\n\nCódigo\nfunction circular_IMU(r, w, t)\n    return [0,w^2*r,w] \nend\n\nfunction circular_GPS(r, w, t)\n    return [r*cos(w*t),r*sin(w*t),w*t+π/2] \nend\n\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#error-de-estimación",
    "href": "TP2_Filtro_Kalman.html#error-de-estimación",
    "title": "TP2 - Filtros de Kalman",
    "section": "Error de estimación",
    "text": "Error de estimación\nSe procede a cuantificar el error de la estimación, el cual se define como la norma cuadrática de la distancia entre la estimación y el valor real\n\\[\n\\epsilon_k = \\left\\lVert\\begin{bmatrix}\\hat{x}_k\\\\\\hat{y}_k\\end{bmatrix}-\n                        \\begin{bmatrix}z^x_k\\\\ z^y_k\\end{bmatrix}\\right\\rVert^2\n\\]\n\n\nCódigo\nfunction error_cuadratico(x, z_true)\n    xs = [[x_i[1] x_i[3]] for x_i in eachcol(x)]\n    zs = [[z_i[1] z_i[2]] for z_i in eachcol(z_true)]\n    return [norm(x_i-z_i)^2 for (x_i, z_i) in zip(xs, zs)]\nend\n\n\nerror_cuadratico (generic function with 1 method)\n\n\nEsto se compara con la incerteza del estimador, la cual se cuantifica con la traza de la matriz de covarianza \\(P\\)\n\n\nCódigo\nfunction varianza_estimador(P)\n    return [tr(P[:,:,i]) for i in 1:size(P,3)]\nend\n\n\nvarianza_estimador (generic function with 1 method)\n\n\nLos resultados verifican las observaciones, y se presentan a continuación\n\n\nCódigo\nfunction plot_error(t, x, z_true, P)\n    v = varianza_estimador(P)\n    e = error_cuadratico(x, z_true)\n    p1 = plot(t, v, ylim=[0, min(100,maximum(v)*1.1)], ylabel=\"Incerteza\")\n    p2 = plot(t, e, ylim=[0, 30], ylabel=\"Error cuadrático\", xlabel=\"t\")\n    return plot(p1, p2, layout=(2,1))\nend\n\nplot_error(t, x, z_true, P)"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#ganancia-de-kalman",
    "href": "TP2_Filtro_Kalman.html#ganancia-de-kalman",
    "title": "TP2 - Filtros de Kalman",
    "section": "Ganancia de Kalman",
    "text": "Ganancia de Kalman\nAdemás del error de medición, se analiza la evolución de la ganancia de Kalman \\(K_k\\) en función del tiempo. Esta se cuantifica como la norma de la matriz.\n\n\nCódigo\nfunction kalman_gain(K)\n    return [norm(K[:,:,i]) for i in 1:size(K,3)]\nend\n\n\nkalman_gain (generic function with 1 method)\n\n\n\n\nCódigo\nfunction plot_gain(t, P, K)\n    v = varianza_estimador(P)\n    k = kalman_gain(K)\n    p1 = plot(t, v, ylabel=\"Incerteza\", linetype=:steppost)\n    p2 = plot(t, k, ylim=[0, maximum(k)*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost)\n    return plot(p1, p2, layout=(2,1))\nend\nfunction plot_gain(t, P1, K1, P2, K2)\n    v1 = varianza_estimador(P1)\n    k1 = kalman_gain(K1)\n    v2 = varianza_estimador(P2)\n    k2 = kalman_gain(K2)\n    p1 = plot(t, v1, ylabel=\"Incerteza\", linetype=:steppost, label=false)\n    plot!(t, v2, ylabel=\"Incerteza\", linetype=:steppost, label=\"Referencia\")\n    p2 = plot(t, k1, ylim=[0, max(maximum(k2),maximum(k2))*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost, label=false)\n    plot!(t, k2, ylim=[0, max(maximum(k2),maximum(k2))*1.1], ylabel=\"Ganancia Kalman\", xlabel=\"t\", linetype=:steppost, label=\"Referencia\")\n    return plot(p1, p2, layout=(2,1))\nend\nplot_gain(t, P, K)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSe hace un foco en el estado estacionario del filtro, para observar como es afectada la incerteza del estimador y la ganacia de Kalman en los instantes en los que se registra una medición del GPS.\n\n\nCódigo\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-gps",
    "href": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incrementa x5 error de GPS",
    "text": "Incrementa x5 error de GPS\n\n\nCódigo\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\nR = [(5*err_GPS)^2 0 0; 0 (5*err_GPS)^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([-3.4394920738686467 -3.439502111004612 … 46.07636578603372 46.096347443328575; 0.0 -0.00020074271930193728 … 0.19996258036642386 0.19967056553076956; … ; 0.0 6.51236732354678e-5 … 0.18222834287508868 0.18242280284890053; 0.7854147984471791 0.7857580972350979 … 0.7857181174373654 0.7856102799360274], [24414.0625 0.0 … 0.0 0.0; 0.0 24414.0625 … 0.0 0.0; … ; 0.0 0.0 … 24414.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 24658.20312500016 2441.4062500032 … -3.2099294956666663e-26 0.0; 2441.4062500032 24414.062500064 … -2.5802684763794945e-24 0.0; … ; 1.853367632049536e-25 -2.33641367938908e-24 … 24414.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 25390.6250000016 4882.812500012799 … -1.6622050786788452e-25 0.0; 4882.812500012799 24414.062500128 … 1.1450525036193166e-25 0.0; … ; -7.945891993640974e-26 -2.2595703671633487e-24 … 24414.062500128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 1.7983434156211553 0.010073579143373998 … 2.9803947618920156e-21 0.0; 0.010073579143374 0.00011387555250521258 … 6.877033673281536e-23 0.0; … ; 9.36784477560193e-22 4.859063418418926e-24 … 0.00011387555250521258 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 1.779851291026657 0.009970091519782714 … 2.943967067457465e-21 0.0; 0.009970091519782716 0.00011329604483888592 … 6.899051859010421e-23 0.0; … ; 9.296537563001733e-22 7.279622785988886e-24 … 0.00011329604483888592 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 1.781846442451062 0.009981424324266602 … 2.950863878960033e-21 0.0; 0.009981424324266604 0.00011336004483888593 … 7.207746096192047e-23 0.0; … ; 9.303412386347986e-22 8.69725213156278e-24 … 0.00011336004483888593 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.9937032664305391 -1.1118054814223955e-33 0.0; 0.09838646202295398 -4.502771749120518e-30 0.0; … ; 7.459018778053517e-30 0.09838646202295398 0.0; 0.0 0.0 0.9999999752491497;;; 0.9938837920489301 -7.982894848290675e-33 0.0; 0.19113149847143707 -1.1877291444103766e-29 0.0; … ; -3.0312455583626435e-30 0.19113149847143707 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.011378438879881426 9.326277524946694e-22 0.0; 6.373732824825261e-5 1.8863669717431908e-23 0.0; … ; 5.944676389955704e-24 6.373732824825261e-5 0.0; 0.0 0.0 0.6968640780830011;;; 0.011391048262570605 9.363433308756971e-22 0.0; 6.380858572660938e-5 1.8904325630304056e-23 0.0; … ; 5.9497840403211095e-24 6.380858572660938e-5 0.0; 0.0 0.0 0.7122418117142865;;; 0.011275236495448655 9.190416722809555e-22 0.0; 6.316084098847408e-5 1.8676392619493602e-23 0.0; … ; 5.903826677495973e-24 6.316084098847408e-5 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([16.560507926131354 16.56048273500945 … 23.214386327741753 23.21800979458549; 0.0 -0.000503822438091478 … 0.036564643480589985 0.03590469339417032; … ; 0.0 -0.00014590240092825408 … 0.24864300005982656 0.24852474653195722; 1.5708129618446274 1.5724128976939822 … 7.853044950952963 7.854193750513061], [24414.0625 0.0 … 0.0 0.0; 0.0 24414.0625 … 0.0 0.0; … ; 0.0 0.0 … 24414.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 24658.20312500016 2441.4062500032 … -6.794641087770046e-30 0.0; 2441.4062500032 24414.062500064 … -1.482273948574e-28 0.0; … ; 7.36161531297499e-30 1.8788190870582313e-28 … 24414.062500064 0.0; 0.0 0.0 … 0.0 6.283185334595154;;; 25390.6250000016 4882.812500012799 … -1.2642509482127546e-28 0.0; 4882.812500012799 24414.062500128 … 1.0744126275138263e-27 0.0; … ; 1.8506810122132774e-28 -5.604429171187768e-27 … 24414.062500128 0.0; 0.0 0.0 … 0.0 6.283185362010721;;; … ;;; 1.7983434156211553 0.010073579143373998 … 2.323885916151569e-21 0.0; 0.010073579143374 0.00011387555250521258 … 1.6719174464086223e-23 0.0; … ; 9.793563520278315e-22 7.813230844076257e-24 … 0.00011387555250521258 0.0; 0.0 0.0 … 0.0 3.575038139502067e-7;;; 1.779851291026657 0.009970091519782714 … 2.2865833833989183e-21 0.0; 0.009970091519782716 0.00011329604483888592 … 1.6417621031137142e-23 0.0; … ; 9.59395188794656e-22 7.679319780708543e-24 … 0.00011329604483888592 0.0; 0.0 0.0 … 0.0 1.1076370392297255e-7;;; 1.781846442451062 0.009981424324266602 … 2.2882242668637576e-21 0.0; 0.009981424324266604 0.00011336004483888593 … 1.6412333163901162e-23 0.0; … ; 9.601623310527678e-22 7.676933037744347e-24 … 0.00011336004483888593 0.0; 0.0 0.0 … 0.0 1.3817927170377632e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.9937032664305391 -1.2181463158708714e-37 0.0; 0.09838646202295398 -2.445539982441331e-34 0.0; … ; 2.952570795550858e-34 0.09838646202295398 0.0; 0.0 0.0 0.9999999752491497;;; 0.9938837920489301 -1.1168451294067755e-35 0.0; 0.19113149847143707 -4.233916538527272e-33 0.0; … ; 7.017686888333444e-33 0.19113149847143707 0.0; 0.0 0.0 0.9999999752491497;;; … ;;; 0.011378438879881426 1.2349953289533784e-21 0.0; 6.373732824825261e-5 1.4603654168833768e-23 0.0; … ; 6.1354191328241214e-24 6.373732824825261e-5 0.0; 0.0 0.0 0.6968640780830011;;; 0.011391048262570605 1.2378700509609218e-21 0.0; 6.380858572660938e-5 1.461377531884948e-23 0.0; … ; 6.140129208285797e-24 6.380858572660938e-5 0.0; 0.0 0.0 0.7122418117142865;;; 0.011275236495448655 1.2129731019029197e-21 0.0; 6.316084098847408e-5 1.4381908737292226e-23 0.0; … ; 6.016375528213683e-24 6.316084098847408e-5 0.0; 0.0 0.0 0.47048808605167836])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-imu",
    "href": "TP2_Filtro_Kalman.html#incrementa-x5-error-de-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incrementa x5 error de IMU",
    "text": "Incrementa x5 error de IMU\n\n\nCódigo\nQ = [(5*err_IMU_x)^2 0 0; 0 (5*err_IMU_x)^2 0; 0 0 (5*err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([1.657026115968656 1.6569683441745213 … 43.51196929304563 43.52707475307199; 0.0 -0.001155435882689861 … 0.15156832473781592 0.150540875789427; … ; 0.0 -0.0004427808112365104 … 0.12490695286295499 0.12302345524436333; 0.7856076827056068 0.7859081781457461 … 0.78437459379551 0.786229415260439], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.453125004 3.90625008 … 8.20268254506302e-24 0.0; 3.90625008 39.0625016 … -2.1234806310617795e-23 0.0; … ; 4.717141712894731e-24 -5.17015364655269e-23 … 39.0625016 0.0; 0.0 0.0 … 0.0 6.2831859925687805;;; 40.62500004 7.812500320000001 … 7.401548198493395e-24 0.0; 7.812500320000001 39.062503199999995 … -4.0803279689868414e-23 0.0; … ; -7.41529726581395e-24 -2.7164458638921246e-23 … 39.062503199999995 0.0; 0.0 0.0 … 0.0 6.283186677957975;;; … ;;; 0.36169288198752264 0.01022958452947423 … -4.460279651733258e-21 0.0; 0.010229584529474227 0.0005721606635761616 … -2.7416341224901115e-22 0.0; … ; 1.0352229768229084e-20 5.302073886110996e-22 … 0.0005721606635761616 0.0; 0.0 0.0 … 0.0 6.320639916249882e-6;;; 0.34373920397192603 0.009721119932253367 … -4.113991983184087e-21 0.0; 0.009721119932253363 0.0005577606635760254 … -2.149090370601535e-22 0.0; … ; 9.552521562783446e-21 4.595199859865528e-22 … 0.0005577606635760254 0.0; 0.0 0.0 … 0.0 1.5213716556903334e-7;;; 0.3456890095650125 0.009776975998610968 … -4.131394791172145e-21 0.0; 0.009776975998610965 0.0005593606635760255 … -3.3788937005665313e-22 0.0; … ; 9.604179490798903e-21 5.130510676391246e-22 … 0.0005593606635760255 0.0; 0.0 0.0 … 0.0 8.375263600891277e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.863247863259832 6.481287762147712e-28 0.0; 0.08547008721303237 -1.590021713338593e-25 0.0; … ; 1.0378118202274625e-25 0.08547008721303237 0.0; 0.0 0.0 0.9999999752491522;;; 0.8666666667804445 1.5084271859684309e-27 0.0; 0.1666666733511111 -1.3069916996275953e-25 0.0; … ; -1.5345024145172726e-25 0.1666666733511111 0.0; 0.0 0.0 0.999999975249155;;; … ;;; 0.05470503370973201 -1.21759549988984e-20 0.0; 0.0015471959620724457 -6.508812350486445e-22 0.0; … ; 1.5219179179453685e-21 0.0015471959620724457 0.0; 0.0 0.0 0.9759866455818303;;; 0.05499827263550817 -1.229588572398899e-20 0.0; 0.0015553791891605383 -6.543575865697645e-22 0.0; … ; 1.5284034500453514e-21 0.0015553791891605383 0.0; 0.0 0.0 0.9782848225201974;;; 0.0524113567306914 -1.1158925396813386e-20 0.0; 0.0014823282274880575 -6.072793139207643e-22 0.0; … ; 1.4176916447789983e-21 0.0014823282274880575 0.0; 0.0 0.0 0.8433959372095443])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P, K = kalman(t, 10, u, z)\n\n\n([21.657026115968655 21.656985128964074 … 19.583840323257903 19.583015704583257; 0.0 -0.0008197400916090282 … -0.00838958185317679 -0.008102791639699299; … ; 0.0 -0.0011801760329088887 … 0.18952330223381691 0.18741491341820157; 1.571005846103055 1.5725629786046302 … 7.8517014273111085 7.8548128858374735], [39.0625 0.0 … 0.0 0.0; 0.0 39.0625 … 0.0 0.0; … ; 0.0 0.0 … 39.0625 0.0; 0.0 0.0 … 0.0 6.283185307179586;;; 39.453125004 3.90625008 … 3.3152438985746904e-27 0.0; 3.90625008 39.0625016 … 2.2708508249453298e-26 0.0; … ; 2.138819621918271e-28 -1.5101559122492603e-26 … 39.0625016 0.0; 0.0 0.0 … 0.0 6.2831859925687805;;; 40.62500004 7.812500320000001 … 1.879741133227766e-27 0.0; 7.812500320000001 39.062503199999995 … -2.0105971463364359e-25 0.0; … ; -1.6283665188125905e-27 3.9184689577891807e-25 … 39.062503199999995 0.0; 0.0 0.0 … 0.0 6.283186677957975;;; … ;;; 0.36169288198752264 0.01022958452947423 … 4.725851403315937e-22 0.0; 0.010229584529474227 0.0005721606635761616 … 1.1505303764174319e-22 0.0; … ; -2.7555457033360704e-22 -1.074771203261049e-22 … 0.0005721606635761616 0.0; 0.0 0.0 … 0.0 6.320639916249882e-6;;; 0.34373920397192603 0.009721119932253367 … 4.848230369404402e-22 0.0; 0.009721119932253363 0.0005577606635760254 … 1.1364851394990373e-22 0.0; … ; -2.909407826446147e-22 -1.0660214700845217e-22 … 0.0005577606635760254 0.0; 0.0 0.0 … 0.0 1.5213716556903334e-7;;; 0.3456890095650125 0.009776975998610968 … 4.9615572530552245e-22 0.0; 0.009776975998610965 0.0005593606635760255 … 1.1329496462625378e-22 0.0; … ; -3.016050049880594e-22 -1.0615281350079544e-22 … 0.0005593606635760255 0.0; 0.0 0.0 … 0.0 8.375263600891277e-7], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.863247863259832 -1.6870240582935919e-31 0.0; 0.08547008721303237 -1.7470583380591837e-29 0.0; … ; 4.584277931641372e-30 0.08547008721303237 0.0; 0.0 0.0 0.9999999752491522;;; 0.8666666667804445 2.3630233245466158e-30 0.0; 0.1666666733511111 -9.46836365770524e-29 0.0; … ; -3.171909842620554e-29 0.1666666733511111 0.0; 0.0 0.0 0.999999975249155;;; … ;;; 0.05470503370973201 -2.674755954198545e-21 0.0; 0.0015471959620724457 6.979026470692419e-23 0.0; … ; -4.4936935617218365e-23 0.0015471959620724457 0.0; 0.0 0.0 0.9759866455818303;;; 0.05499827263550817 -2.660000542084261e-21 0.0; 0.0015553791891605383 7.150858086484715e-23 0.0; … ; -4.655052522313836e-23 0.0015553791891605383 0.0; 0.0 0.0 0.9782848225201974;;; 0.0524113567306914 -2.374929471227443e-21 0.0; 0.0014823282274880575 7.319770561249447e-23 0.0; … ; -4.849708322789433e-23 0.0014823282274880575 0.0; 0.0 0.0 0.8433959372095443])\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_error(t, x, z_true, P)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nplot_gain(t[k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#actualización-por-medición",
    "href": "TP2_Filtro_Kalman.html#actualización-por-medición",
    "title": "TP2 - Filtros de Kalman",
    "section": "Actualización por medición",
    "text": "Actualización por medición\nLa actualización por medición se basa en relacionar las mediciones del GPS y el magnetómetro con el estado actual \\(\\mathbf{\\hat{x}}\\) de la siguiente forma\n\\[\n\\mathbf{z}_k = H\\mathbf{\\hat{x}}_k - \\mathbf{v}_k\n\\]\nEn donde la matriz \\(H\\) es dada por\n\\[\nH =  \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nY el vector de ruido tiene matriz de covarianza \\(R\\)\n\n\nCódigo\nA = [1 Δt 0 0 0;\n     0 1 0 0 0;\n     0 0 1 Δt 0;\n     0 0 0 1 0;\n     0 0 0 0 1]\n\nfunction B_matrix(θ)\n    return [Δt^2*cos(θ)/2 -Δt^2*sin(θ)/2 0;\n    Δt*cos(θ) -Δt*sin(θ) 0;\n    Δt^2*sin(θ)/2 Δt^2*cos(θ)/2 0;\n    Δt*sin(θ) Δt*cos(θ) 0;\n    0 0 Δt]\nend\n\nH = [1 0 0 0 0;\n     0 0 1 0 0;\n     0 0 0 0 1]"
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-gps",
    "href": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-gps",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incremento x5 del error de GPS",
    "text": "Incremento x5 del error de GPS\nPrimero se analiza que sucede si el error del IMU se mantiene igual y el error del GPS incrementa 5 veces. Esto se realiza ejecutando el programa pero utilizando la siguiente matriz de covariaza para el ruido de medición\n\\[\n  R = \\begin{bmatrix}\n    (5\\sigma_{GPS})^2 & 0 & 0\\\\\n    0 & (5\\sigma_{GPS})^2 & 0\\\\\n    0 & 0 & (\\sigma_{mag})^2\\\\\n  \\end{bmatrix}\n\\]\nSe analiza las trayectorias rectilínea y circular, y los resultados se presentan a continuación.\n\nTrayectoria rectilínea\n\n\nCódigo\nQ = [err_IMU_x^2 0 0; 0 err_IMU_x^2 0; 0 0 err_IMU_θ^2]\nR = [(5*err_GPS)^2 0 0; 0 (5*err_GPS)^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrayectoria circular\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nk1 = 4800\nk2 = 4850\nplot_gain(t[k1:k2], P2[:,:,k1:k2], K2[:,:,k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservaciones\n\nEl error de estimación es mucho mayor respecto al caso de referencia, en particular cerca del inicio de la trayectoria.\nEl filtro tarda mucho más tiempo en alcanzar el estado estacionario respecto al caso de referencia.\nA pesar que la incerteza de medición es mucho mayor, en el estado estacionario la ganancia de Kalman es similar a aquella del caso de referencia."
  },
  {
    "objectID": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-imu",
    "href": "TP2_Filtro_Kalman.html#incremento-x5-del-error-de-imu",
    "title": "TP2 - Filtros de Kalman",
    "section": "Incremento x5 del error de IMU",
    "text": "Incremento x5 del error de IMU\nA continuación se analiza que sucede si el error del IMU es el que incrementa 5 veces y el error del GPS se mantiene igual. Esto se realiza ejecutando el programa pero utilizando la siguiente matriz de covariaza para el ruido de modelo\n\\[\n  Q = \\begin{bmatrix}\n    (5\\sigma_{acc})^2 & 0 & 0\\\\\n    0 & (5\\sigma_{acc})^2 & 0\\\\\n    0 & 0 & (5\\sigma_{gir})^2\\\\\n  \\end{bmatrix}\n\\]\n\nTrayectoria rectilínea\n\n\nCódigo\nQ = [(5*err_IMU_x)^2 0 0; 0 (5*err_IMU_x)^2 0; 0 0 (5*err_IMU_θ)^2]\nR = [err_GPS^2 0 0; 0 err_GPS^2 0; 0 0 err_MAG^2]\n\ndist_ruido_IMU = MvNormal([0,0,0], Q)\ndist_ruido_GPS = MvNormal([0,0,0], R)\n\nu_noise = hcat([rand(dist_ruido_IMU) for ti in t]...)\nz_noise = hcat([rand(dist_ruido_GPS) for ti in t]...)\n\nu_true = hcat([mrua_IMU(5e-4) for ti in t]...)\nz_true = hcat([mrua_GPS(5e-4, ti, pi/4) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrayectoria circular\n\n\nCódigo\nu_true = hcat([circular_IMU(20, 2*pi/T, ti) for ti in t]...)\nz_true = hcat([circular_GPS(20, 2*pi/T, ti) for ti in t]...)\n\nu = u_true + u_noise\nz = z_true + z_noise\n\nx, P2, K2 = kalman(t, 10, u, z, Q, R)\n\n\n\n\nCódigo\ntrayectoria_xy(x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\ntrayectoria_t(t, x, z_true)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError de estimación\n\n\nCódigo\nplot_error(t, x, z_true, P2)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nk1 = 4000\nk2 = 4050\nplot_gain(t[k1:k2], P2[:,:,k1:k2], K2[:,:,k1:k2], P[:,:,k1:k2], K[:,:,k1:k2])\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservaciones\n\nEl error de estimación es mayor respecto al caso de referencia, pero la diferencia no es tan drástica como en el caso que incrementa el error del GPS.\nNo se ve afectado el tiempo que tarda el filtro en alcanzar el estado estacionario respecto al caso de referencia.\nEl error de estimador es mayor respecto al caso de referencia, incluso en el estado estacionario.\nSe nota que la ganancia de Kalman es mayor respecto al caso de referencia. Esto implica que las mediciones del GPS se consideran más informativas."
  }
]